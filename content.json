{"pages":[{"title":"","text":"{\"name\":\"App\",\"icons\":[{\"src\":\"/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"/android-icon-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\",\"density\":\"2.0\"},{\"src\":\"/android-icon-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\",\"density\":\"3.0\"},{\"src\":\"/android-icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":\"4.0\"}]}","link":"/manifest.json"},{"title":"关于","text":"邮件: yanzhaou@mail.ustc.edu.cn关注公众号: 程序员的脑洞小程序: 拍照数数","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"[{\"name\":\"2020罗兰贝格中国行业趋势报告\",\"path\":\"2020罗兰贝格中国行业趋势报告\",\"imgNums\":52,\"imgFormat\":\".jpg\"},{\"name\":\"2020年Facebook-IQ-热门话题和趋势报告\",\"path\":\"2020年Facebook-IQ-热门话题和趋势报告\",\"imgNums\":34,\"imgFormat\":\".jpg\"},{\"name\":\"领英2020人才趋势报告\",\"path\":\"领英2020人才趋势报告\",\"imgNums\":84,\"imgFormat\":\".png\"}]","link":"/static-files/global-trends/items-0.json"}],"posts":[{"title":"H5:echarts的tooltip与datazoom的优化","text":"echarts版本3.X.X 在移动端同时使用Echarts的tooltip和datazoom时，你会发现tooltip显示的时候很难去对图表进行放大、缩小、水平移动，也就是比较难触发datazoom事件，用户体验有点差。因此，本文提出了一些优化方法，以便提高用户体验。 ## 1. 交互套路 既然要优化，那就需要将tooltip和datazoom这两个事件拆分开，不能让它们同时触发。所以，交互的总方针是： 1. tooltip隐藏时，即允许datazoom也允许显示tooltip； 2. 点击，tooltip显示，datazoom无效；再次点击，tooltip隐藏，允许datazoom 3. 只有tooltip隐藏时，才允许datazoom。 2. 实现实现时需要接管tooltip的触发，同时也要控制datazoom是否可用 2.1 接管tooltip2.1.1 echarts配置echarts在配置tooltip提示框触发的条件： 123tooltip: { triggerOn: 'none'} 不在’mousemove’或’click’时触发，我们改用dispatchAction来触发tooltip显示。 2.1.2 主动触发tooltip，允许datazoom我们需要处理图表dom标签的Touch事件，从而来主动分发showtip事件。按照我们的交互总方针，以下流程中的每一次允许tooltip，都伴随这禁用datazoom；每一次隐藏tooltip都伴随着启用datazoom。处理Touch事件以及分发showtip的基本流程为： 2.1.2.1 touchstart事件 记录触发了touchstart 记录并判断是不是多个手指，若是则隐藏tooltip，并允许datazoom。 触发长按计时器，如果是长按，则要触发tooltip，并禁用datazoom。用户移动手指，来达到连续显示tooltip。 2.1.2.2 touchmove事件 记录触发了touchmove事件 如果tooltip是不显示的状态，则要清除长按计时器，因为此时用户想要移动图表。并且，前提在tooltip是不显示的状态时，允许datazoom。如果tooltip是显示状态，则用户要达成连续显示tooltip。 如果是长按，则需要显示tooltip 2.1.2.3 touchend事件 清除长按计时器； 如果是多个手指操作，则函数结束，剩余流程不用处理； 如果是长按，则显示tooltip，重置touch事件的状态，并return； 2和3的条件都没满足的情况下，则表示用户是单次点击，如果tooltip是隐藏状态，则显示tooltip；如果tooltip是显示状态，则隐藏tooltip； 重置touch状态。 2.2 datazoom处理datazoom的处理只需要注意一个地方：拖动图表后，会触发touchend事件，可能会触发tooltip。所以，如果需要显示tooltip，则需要将在业务逻辑里面，监听到datazoom后，隐藏tooltip。","link":"/2018/05/25/H5-echarts%E7%9A%84tooltip%E4%B8%8Edatazoom%E7%9A%84%E4%BC%98%E5%8C%96/"},{"title":"About:create-react-app","text":"create-react-app是facebook官方维护的一套react开发框架（emmm…应该说是配置），目前的star数量接近5w+，可见其受欢迎程度。相比于其他一些react开发框架，例如react-boilerplate、react-starter-kit(star数都接近2w+)，create-react-app似乎更容易react初学者上手。 HMR(hot module replace)在使用的过程中，发现create-react-app不能做到HMR，每次修改代码都是整个页面刷新。这不可能，这么受欢迎的项目，怎么没有默认开启HMR？ 在运行npm run eject后，发现在其配置文件webpack.config.dev.js文件中已经引用相应的webpack配置： 1234567// Add module names to factory functions so they appear in browser profiler.new webpack.NamedModulesPlugin(),// Makes some environment variables available to the JS code, for example:// if (process.env.NODE_ENV === 'development') { ... }. See `./env.js`.new webpack.DefinePlugin(env.stringified),// This is necessary to emit hot updates (currently CSS only):new webpack.HotModuleReplacementPlugin(), 同时在webpackDevServer.config.js文件中也配置了hot： 123456// Enable hot reloading server. It will provide /sockjs-node/ endpoint// for the WebpackDevServer client so it can learn when the files were// updated. The WebpackDevServer client is included as an entry point// in the Webpack development configuration. Note that only changes// to CSS are currently hot reloaded. JS changes will refresh the browser.hot: true, 对比webpack官网，需要在入口的js文件index.js文件中增加： 123if (module.hot) { module.hot.accept()} BrowserRouter与HashRoutervue-router有两种模式：hash模式和history模式。history模式需要服务端配合，否则会有一些小问题。 react-router中也存在这两种模式。BrowserRouter即为history模式，HashRouter即为hash模式。我们在部署的时候，如果将项目放在web服务器静态资源的二级目录中，则往往需要修改web服务器或者改用HashRouter，否则会出现找不到资源的情况。 react函数式组件，事件处理对于简单的组件，可以采用函数式来定义react组件。函数式组件可以简单快速的定义一个react组件，但是有一个缺点是：无状态。这里提供一个简单的事件处理demo： 12345678910111213141516171819import React from 'react'import s from './index.less'import close from '../../assets/imgs/close.png'function Footer (props) { const handleClose = () =&gt; { document.querySelector('#footer').style.display = 'none' } return ( &lt;footer className={s.footer} id='footer'&gt; &lt;img onClick={handleClose} src={close} className={s.close}/&gt; &lt;/footer&gt; )}export default Footer","link":"/2018/05/22/About-create-react-app/"},{"title":"10-SQL-tricks","text":"","link":"/2018/07/17/10-SQL-tricks/"},{"title":"10-years-of-GitHub","text":"上个月，也就是2018年4月10日是GitHub十周年，GitHub创始人Chris Wanstrath发布了一篇文章来总结这十年的发展。 回顾往昔十载，我们记住的不是某一个软件，而是人们用来做了什么。 （以下内容为译文）Chris Wanstrath： 10年前，GitHub正式上线。我们的意图其实很简单：连接开发者，让他们十分方便的通过Git一起编写项目。在过去十年里，我们已经发展成为一家公司和平台，但是GitHub的初衷不变。使这个平台特别的不是一个想法或者发明，而是使用这个平台的人们：GitHub因为你，我们的社区，才能有今天的十周年庆。 当我们回顾往昔十载，我们记住的不是某一个软件，而是人们用来做了什么。在GitHub上，我们可以与全世界一起分享、传授、创建项目。在GitHub发布时，我们没有预料到会有这么多的项目、程序和大型框架会出现在GitHub上。我们也没有想到企业会在开源社区投入如此巨大，也不曾想到会有那么多人学习彼此的代码。 GitHub发布的时候，正好是技术以新的方式将人们联系起来的时候，但是，正如我在十年前发的文章，让我们不要在旅途中高声宣扬，你的工作说明了一切。我们收集了一些我们喜欢的时刻和里程碑，以此来庆祝大家推进软件开发的方式。 展望未来，我会使GitHub保持简单。您一起定义了今天的软件，在未来几年，您将继续塑造未来。那么未来十年将会出现什么软件？我们跟随将你的领导。 与此同时，我们感谢您提交(committed)的代码、您合并的请求（pull request）、您编写的文档、您分享的项目，以及因您才有GitHub的十年。对此，我们非常感谢，迫不及待的想看看您下一步要build什么。 10年，感谢有你！2008年4月10日：GitHub正式上线在2008年4月，GitHub beta版测试完成，并正式上线，其目的仅仅是：连接开发者，让他们十分方便的通过Git一起工作。 2008年4月3日：Rails迁移到GitHub在GitHub还是beta版时，Ruby on Rails是第一个加入GitHub的开源大项目。这对GitHub而言是一个重要的时刻，因为GitHub建立在Rails之上。 2009年1月3日：比特币出现比特币是世界上第一个去中心化的数字货币，2009年被发明，并于2010年入驻GitHub。迄今为止，比特币项目已经有超过18000个分支（截止本稿，为19006个分支，star数为3w+），500多个合并请求，并激励了GitHub上数千个区块链项目，其中很多是比特币源码的分支。 2009年5月21日：Node.js发布Node.js于2009年发布，它导致人们使用JavaScript的方式发生了根本性的变化。借助Node.js，开发人员可以使用Angular、Ember、React、jQuery和Vue等库和框架，在系统上构建复杂的服务器端和桌面应用程序。该项目有效的扩展了JavaScript的可能性，并推动了一种主要的编程语言。 2014年，io.js从Node.js分化出来，致力于社区的开放性。一年后，两个项目都建立开放式的管理模式，并成立Node.js基金会进行重组，开源社区的影响力，对两个项目的重组起到了重要作用。 今天，Node.js核心拥有近2000个贡献者，Node.js也形成了丰富的生态系统，包含大量的库和工具。由于社区驱动的NodeSchool相对容易学习，NodeSchool连接开发者，提供免费教程，并在全球举办面对面的活动。 2010年11月26日：Rails Girls Summer of Code举办第一次研讨会Rails Girls(目标是为女性提供工具和社区)于2010年在Helsinki举行了首次活动。在2013年，Rails Girls成员开始筹备Summer of Code(编码夏令营):一个针对女性和非二进制编码的全球奖学金计划。学生将获得三个月的奖学金，以开展现有的开放源代码项目并扩展他们的技能。除了Google Summer of Code、Outreachy等，Rails Girls Summer of Code也对软件行业产生了影响。他们不久前举办了5周年庆典，所以现在是支持他们工作的好时机。 2011年2月28日：Travis CI的第一个pull请求Travis CI发布于2011年，其用于开源代码和私有项目的持续集成，是第一个与GitHub集成的开发者工具。Jenkins和CircleCI也在同一时间成立，这使得2011年成为CI（持续集成）和软件构建的重要一年。测试已成为编写更安全、更可靠代码的关键部分。 2012年1月1日：JavaScript成为GitHub上最受欢迎的语言2012年JavaScript的表演开始了，超越Ruby、Java和Python，成为GitHub上最流行的语言。时至今日，JavaScript仍然是GitHub上最受欢迎的语言。 2013年1月16日：GitHub社区用户达到300万在2013年晚些时候，我们的社区开源代码库达到了1000万个，其中包括Project Open Data(好像一种将数据进行开放的开源项目，以便其他人可以对数据进行管理、使用，译者不是很了解) 2014年6月9日：Docker 1.0发布在第一版发布后一年多一点，2014年6月Docker 1.0的发布，将Docker容器引入了企业数据中心和云平台。像Docker和Kubernetes这样的项目，推动了容器技术的发展，简化了DevOps，将团队从基础架构中解放出来，使得可以专注于最重要的地方。 2014年7月21日：首届Django Girls讲习班第一届Django Girls在2014年柏林EuroPython举办，开启了为期四年的世界各地软件培训和女性支持工作。 支持他们的工作，以保持Django Girls社区的成长。 2014年10月23日：微软开源.NET.NET和.NET基金会只是微软开源计划的开端。现在微软已经开源了数百个项目。它们包括去年贡献者最多的VS Code（Visual Studio Code编辑器）和2017年发展最快的语言之一：TypeScript。 微软也称为GitHub上最活跃的贡献者之一，数千名工程师、设计师和程序员在GitHub平台上贡献和发布代码。 像微软和Google这样的大公司对开源的投资，改变了人们对于商业企业构建软件的观点。他们还向我们表明，他们成功的秘诀有时不是他们所创建的技术，而是如何使用技术。 2015年3月2日：虚幻引擎4源码公布Epic Games团队免费公布了虚幻引擎4，用一些最好的工具打破了游戏开发者与他们的创意愿景之间的障碍。免费的源代码还允许社区提前体验到引擎的新特性。从bug的修复看，他们的最新版本有128位贡献者。 由于游戏引擎、相关的库和开发者工具的开源，使得游戏成为GitHub上2017年最受欢迎的主题之一。Phaser，Godot Engine和其他项目，如Itch.io，正在塑造人们建立和分享独立游戏的方式。像2048这样的开源学习资源和游戏 - 启发了数百个克隆 - 邀请了更多的人参与和创造。 受此影响，包括Doom和Price of Persia在内的一些最有影响力的游戏代码也都开源了，开源总比他们被埋没在新墨西哥沙漠（垃圾填埋场）中要好。 2015年9月22日：GitHub课堂开课GitHub课堂使教师更容易分发代码任务并收集GitHub上的作业。 今天，高中，大学和编码训练营的学生正在学习180万个课堂知识库 - 但这些远不是GitHub上唯一的教育资源。 从资源清单到像edX和Udacity这样的大型开放式在线课程（MOOC），您已经创建了数千种方法来学习GitHub上的软件开发。 我们名单上的课程包括Ada的Jumpstart计划和斯坦福大学的TensorFlow教程。 STAT545正在教授数千名学生处理数据，而CS50正在美国各地的教室中采用。 在过去的十年中，像Django Girls这样的社区驱动计划已经启动了在线教程，举办了面对面的活动，并为世界各地的学生拓宽了学习机会。 我们的校园专家还在超过15个国家的校园建立技术社区。 2015年12月3日： 苹果开源Swift将Swift作为开源语言发布的决定提高了开发新工具的标准，并鼓励更多的公司向公众发布工具。 2016年7月9日：阿波罗11号代码发射阿波罗11号于1969年登陆月球。四十七年后，启动阿波罗11号的源代码登陆GitHub。 由于其中包含的复活节彩蛋数量很大，这也证明了20世纪60年代的程序员也有幽默感。 除了存储过去的代码之外，组织正在通过开源和闭源软件推动现代航天和探索其他科学研究领域。 NASA维护着数百个开源项目。 在公共仓库中，您会发现可视化火星地形并使用TensorFlow识别系外行星的软件。 您还可以找到一些SpaceX这样的组织使用的开源项目。 2017年2月10日：Python团队执行了他们的第一个GitHub拉取请求Python的维护者宣布他们计划在2016年初迁移到GitHub上，并在第二年开始他们的第一次拉取请求。在过去十年中，Python已经成为增长最快的主要编程语言之一。自2015年以来，它在GitHub最流行语言排行榜中一直排名第三。 Python的历史可以追溯到20世纪90年代初，但近年来它变得越来越重要。 这可能是由于其社区建立了庞大的数据科学和机器学习工具生态系统。 2017年2月15日：TensorFlow 1.0发布谷歌首先在2015年将其内部机器学习库TensorFlow公开。去年，它是GitHub上分支最多的项目之一，TensorFlow / models库在2017年的访问量比2016年多5.5倍。现在，TensorFlow是一个 为数据专业人员创建机器学习模型的首选工具。 近年来，机器学习的可能性已经超出限制。 组织和个人使用TensorFlow创建诊断精神疾病，分类皮肤癌，组合音乐和开动Mario Karts（自动驾驶）的模型。 今天，数据科学家可以使用一系列开源深度学习工具和模型来解决复杂而有趣的问题。 除了TensorFlow之外，Caffe2，Sonnet，DeepSpeech和Keras等工具以及pandas和Jupyter等数据分析工具也支持跨行业的数据科学工作。 2017年5月2日：30,000个非营利帐户被创建非营利组织和非政府组织（NGO）通过技术发生令人难以置信的事情。 去年，我们通过Human Utility，Maven和ConnectHome等举措让30,000个非营利用户使世界变得更美好。 野生动物保护协会（WCS）的海洋保护努力涵盖25个国家，以保护和保护世界珊瑚礁。 在肯尼亚，WCS使用软件收集全球研究人员的数据，并通过收集物种数据和监测更多252公顷的沿海礁石 - 约260个足球场的价值，帮助当地社区更有利可图地进行捕捞。 2017年5月31日：第1亿次拉取请求很多bug被修复，众多新功能发布以及软件的不断改进。事实上，仅2017年，社区便贡献了2.9万亿行代码。 2018年4月10日：代码、协作和提交的十年GitHub正式推出十年后，我们的社区已经发展到全球拥有超过8000万个项目的2700万名开发人员。 感谢您创建的代码库，您所做的贡献以及您一起构建的软件。 感谢当了10年码农的你（哈哈，差不多这个意思啦）。","link":"/2018/05/18/10-years-of-GitHub/"},{"title":"J2V8实现Java与Javascript互相调用","text":"J2V8实现Java与Javascript互相调用 Java调用JS方法编写一个返回String的JS方法 1234// jsfunction javaCallJSFunc (msg) { return msg + ' -&gt; Hi, Java!'} 引入J2V8库时可以引入jar或者Android的aar包，或者自行编译。例如Android Studio引入：implementation 'com.eclipsesource.j2v8:j2v8:4.8.2@aar'下述例子均是在Android中运行。 12345678910111213// javavoid javaCallJSFunc () { V8 jsRuntime = V8.createV8Runtime(); jsRuntime.executeScript(\"function javaCallJSFunc (msg) {\\n\" + \" return msg + ' -&gt; Hi, Java!'\\n\" + \"}\"); // 添加参数 V8Array params = new V8Array(jsRuntime).push(\"Hi, Javascript!\"); String result = jsRuntime.executeStringFunction(\"javaCallJSFunc\", params); Log.e(\"Test\", \"javaCallJSFunc result = \" + result); // 需手动释放资源 jsRuntime.release();} JS调用Java方法js调用Java方法，从实现方式上有两种：JavaCallback、Relfectively JavaCallback假设我们在Javascript中调用Java的setData方法 123//jsvar date = new Date().toDateString()setData(date) 在Java中实例化一个JavaVoidCallback的匿名类 1234567891011121314151617181920212223// java// jsCallJavaFunc js调用Java方法void jsCallJavaFunc () { V8 jsRuntime = V8.createV8Runtime(); JavaVoidCallback setData = new JavaVoidCallback() { @Override public void invoke(V8Object v8Object, V8Array v8Array) { if (v8Array.length() &gt; 0) { // 获取js传入的参数 Object arg1 = v8Array.get(0); Log.i(\"J2V8\", \"jsCallJavaFunc -&gt; \" + arg1.toString()); if (arg1 instanceof Releasable) { ((Releasable) arg1).release(); } } } }; jsRuntime.registerJavaMethod(setData, \"setData\"); jsRuntime.executeScript(\"var date = new Date().toDateString()\\n\" + \" setData(date)\"); // 需手动释放资源 jsRuntime.release();} Relfectively更确切的说是类似于在Javascript中，给对象定义方法，也就是js调用Java Object的方法。创建一个Java类，该类包含Javascript可以调用的方法。 1234567// java...public class JSBridge { public void setData (String data) { Log.i(\"JSBridge\", data); }} 在js中调用JSBridge.setData方法 12var date = new Date().toDateString()JSBridge.setData(date) 在Java中将JSBridge暴露给js 123456789101112// javavoid jsCallJavaObject () { JSBridge jsBridge = new JSBridge(); V8Object jsBridgeObj = new V8Object(jsRuntime); // 将jsBridge暴露给js jsRuntime.add(\"JSBridge\", jsBridgeObj); // 注册方法 jsBridgeObj.registerJavaMethod(jsBridge, \"setData\", \"setData\", new Class&lt;?&gt;[] {String.class}); jsBridgeObj.release(); jsRuntime.executeScript(\"var date = new Date().toDateString()\\n\" + \"JSBridge.setData(date)\");}","link":"/2019/02/18/Registering-Java-Callbacks-width-J2V8/"},{"title":"a-blockchain-implementation-in-200-lines","text":"https://github.com/lhartikk/naivechain 一段200行代码实现区块链的nodejs代码解析 source code 函数解析initHttpServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236'use strict';var CryptoJS = require(\"crypto-js\");var express = require(\"express\");var bodyParser = require('body-parser');var WebSocket = require(\"ws\");var http_port = process.env.HTTP_PORT || 3001;var p2p_port = process.env.P2P_PORT || 6001;var initialPeers = process.env.PEERS ? process.env.PEERS.split(',') : [];// 块定义class Block { constructor(index, previousHash, timestamp, data, hash) { this.index = index; this.previousHash = previousHash.toString(); this.timestamp = timestamp; this.data = data; this.hash = hash.toString(); }}var sockets = [];var MessageType = { QUERY_LATEST: 0, QUERY_ALL: 1, RESPONSE_BLOCKCHAIN: 2};var getGenesisBlock = () =&gt; { return new Block(0, \"0\", 1465154705, \"my genesis block!!\", \"816534932c2b7154836da6afc367695e6337db8a921823784c14378abed4f7d7\");};// 链var blockchain = [getGenesisBlock()];var initHttpServer = () =&gt; { var app = express(); app.use(bodyParser.json()); // 查询blocks，返回blockchain app.get('/blocks', (req, res) =&gt; res.send(JSON.stringify(blockchain))); // 挖矿，新增block app.post('/mineBlock', (req, res) =&gt; { // 生成下一个block var newBlock = generateNextBlock(req.body.data); // 校验index\\previousHash\\hash是否正确，并将正确的block插入链 addBlock(newBlock); // 给sockets内所有链接，广播链上最后一个block broadcast(responseLatestMsg()); console.log('block added: ' + JSON.stringify(newBlock)); res.send(); }); // 查询所有节点 app.get('/peers', (req, res) =&gt; { res.send(sockets.map(s =&gt; s._socket.remoteAddress + ':' + s._socket.remotePort)); }); // 新增节点 app.post('/addPeer', (req, res) =&gt; { // {\"peer\" : \"ws://localhost:6001\"} // 连接，创建websocket连接到req.body.peer connectToPeers([req.body.peer]); res.send(); }); app.listen(http_port, () =&gt; console.log('Listening http on port: ' + http_port));};var initP2PServer = () =&gt; { // 创建WebSocket服务 var server = new WebSocket.Server({port: p2p_port}); // 响应连接请求, server.on('connection', ws =&gt; initConnection(ws)); console.log('listening websocket p2p port on: ' + p2p_port);};var initConnection = (ws) =&gt; { // 将ws记录到sockets列 sockets.push(ws); initMessageHandler(ws); initErrorHandler(ws); // 查询链上最新的块 write(ws, queryChainLengthMsg());};var initMessageHandler = (ws) =&gt; { ws.on('message', (data) =&gt; { var message = JSON.parse(data); console.log('Received message' + JSON.stringify(message)); switch (message.type) { case MessageType.QUERY_LATEST: write(ws, responseLatestMsg()); break; case MessageType.QUERY_ALL: write(ws, responseChainMsg()); break; case MessageType.RESPONSE_BLOCKCHAIN: handleBlockchainResponse(message); break; } });};var initErrorHandler = (ws) =&gt; { var closeConnection = (ws) =&gt; { console.log('connection failed to peer: ' + ws.url); sockets.splice(sockets.indexOf(ws), 1); }; ws.on('close', () =&gt; closeConnection(ws)); ws.on('error', () =&gt; closeConnection(ws));};var generateNextBlock = (blockData) =&gt; { var previousBlock = getLatestBlock(); var nextIndex = previousBlock.index + 1; var nextTimestamp = new Date().getTime() / 1000; var nextHash = calculateHash(nextIndex, previousBlock.hash, nextTimestamp, blockData); return new Block(nextIndex, previousBlock.hash, nextTimestamp, blockData, nextHash);};var calculateHashForBlock = (block) =&gt; { return calculateHash(block.index, block.previousHash, block.timestamp, block.data);};var calculateHash = (index, previousHash, timestamp, data) =&gt; { return CryptoJS.SHA256(index + previousHash + timestamp + data).toString();};var addBlock = (newBlock) =&gt; { if (isValidNewBlock(newBlock, getLatestBlock())) { blockchain.push(newBlock); }};var isValidNewBlock = (newBlock, previousBlock) =&gt; { if (previousBlock.index + 1 !== newBlock.index) { console.log('invalid index'); return false; } else if (previousBlock.hash !== newBlock.previousHash) { console.log('invalid previoushash'); return false; } else if (calculateHashForBlock(newBlock) !== newBlock.hash) { console.log(typeof (newBlock.hash) + ' ' + typeof calculateHashForBlock(newBlock)); console.log('invalid hash: ' + calculateHashForBlock(newBlock) + ' ' + newBlock.hash); return false; } return true;};var connectToPeers = (newPeers) =&gt; { newPeers.forEach((peer) =&gt; { var ws = new WebSocket(peer); ws.on('open', () =&gt; initConnection(ws)); ws.on('error', () =&gt; { console.log('connection failed') }); });};// 校验block，是否要拼接为链上新block。否则替换整个链var handleBlockchainResponse = (message) =&gt; { // 排序，index升序 var receivedBlocks = JSON.parse(message.data).sort((b1, b2) =&gt; (b1.index - b2.index)); var latestBlockReceived = receivedBlocks[receivedBlocks.length - 1]; var latestBlockHeld = getLatestBlock(); // 校验block，是否要拼接为链上新block if (latestBlockReceived.index &gt; latestBlockHeld.index) { console.log('blockchain possibly behind. We got: ' + latestBlockHeld.index + ' Peer got: ' + latestBlockReceived.index); if (latestBlockHeld.hash === latestBlockReceived.previousHash) { console.log(\"We can append the received block to our chain\"); blockchain.push(latestBlockReceived); // 广播最新的block broadcast(responseLatestMsg()); } else if (receivedBlocks.length === 1) { console.log(\"We have to query the chain from our peer\"); broadcast(queryAllMsg()); } else { console.log(\"Received blockchain is longer than current blockchain\"); replaceChain(receivedBlocks); } } else { console.log('received blockchain is not longer than current blockchain. Do nothing'); }};// 校验是否为起始block，若为是，则替换为新链var replaceChain = (newBlocks) =&gt; { if (isValidChain(newBlocks) &amp;&amp; newBlocks.length &gt; blockchain.length) { console.log('Received blockchain is valid. Replacing current blockchain with received blockchain'); blockchain = newBlocks; broadcast(responseLatestMsg()); } else { console.log('Received blockchain invalid'); }};// 校验链关系是否正确var isValidChain = (blockchainToValidate) =&gt; { // 判断是否为起始block if (JSON.stringify(blockchainToValidate[0]) !== JSON.stringify(getGenesisBlock())) { return false; } // 校验block之间的关系是否为单链 var tempBlocks = [blockchainToValidate[0]]; for (var i = 1; i &lt; blockchainToValidate.length; i++) { if (isValidNewBlock(blockchainToValidate[i], tempBlocks[i - 1])) { tempBlocks.push(blockchainToValidate[i]); } else { return false; } } return true;};var getLatestBlock = () =&gt; blockchain[blockchain.length - 1];var queryChainLengthMsg = () =&gt; ({'type': MessageType.QUERY_LATEST});var queryAllMsg = () =&gt; ({'type': MessageType.QUERY_ALL});var responseChainMsg = () =&gt;({ 'type': MessageType.RESPONSE_BLOCKCHAIN, 'data': JSON.stringify(blockchain)});var responseLatestMsg = () =&gt; ({ 'type': MessageType.RESPONSE_BLOCKCHAIN, 'data': JSON.stringify([getLatestBlock()])});var write = (ws, message) =&gt; ws.send(JSON.stringify(message));var broadcast = (message) =&gt; sockets.forEach(socket =&gt; write(socket, message));// 链接空数组或者命令行传入节点connectToPeers(initialPeers);// 启动服务initHttpServer();// 启动P2PServerinitP2PServer();","link":"/2021/04/06/a-blockchain-implementation-in-200-lines/"},{"title":"ace富文本编辑器源码解析","text":"ace富文本编辑器，是一款不错的JavaScript实现的富文本编辑器。它没有采用html的contentEditable实现，而是采用一种自行渲染、类似虚拟DOM的方式实现。我们对阅读了其源码，以期了解其实现原理。 大段源码警告 入口使用ace，初始化代码为 12345&lt;div id=\"editor\"&gt;some text&lt;/div&gt; &lt;script src=\"build/src/ace.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; &lt;script&gt; var editor = ace.edit(\"editor\"); &lt;/script&gt; 也就是入口函数为ace.edit。在获取ace源码后，运行node ./Makefile.dryice.js命令进行build后，在build/src文件夹内可以得到ace完整的源码。在build/src/ace.js文件中找到edit函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243exports.edit = function(el, options) { if (typeof el == \"string\") { var _id = el; // 只支持dom的ID属性 el = document.getElementById(_id); if (!el) throw new Error(\"ace.edit can't find div #\" + _id); } if (el &amp;&amp; el.env &amp;&amp; el.env.editor instanceof Editor) return el.env.editor; var value = \"\"; if (el &amp;&amp; /input|textarea/i.test(el.tagName)) { var oldNode = el; value = oldNode.value; el = dom.createElement(\"pre\"); oldNode.parentNode.replaceChild(el, oldNode); } else if (el) { value = el.textContent; el.innerHTML = \"\"; } // 创建编辑会话 // 返回EditSession对象 var doc = exports.createEditSession(value); // 创建编辑器 var editor = new Editor(new Renderer(el), doc, options); var env = { document: doc, editor: editor, onResize: editor.resize.bind(editor, null) }; if (oldNode) env.textarea = oldNode; event.addListener(window, \"resize\", env.onResize); editor.on(\"destroy\", function() { event.removeListener(window, \"resize\", env.onResize); env.editor.container.env = null; // prevent memory leak on old ie }); editor.container.env = editor.env = env; return editor;}; Editor(new Renderer(el), doc, options)Renderer：VirtualRendererRenderer用到了VirtualRenderer。VietualRender初始化时创建了一些DOM，如下图。 ace_gutter: 显示左侧的行序列 ace_scroller: 包裹正文（ace_content）显示部分 ace_scrollbar: 滚动条，分为垂直和水平滚动条 ace_content内分为很多层layer: ace_print-margin-layer: ace_marker-layer: ace_text-layer: ace_cursor-layer: VirtualRenderer指明了光标位置属性。 1234this.cursorPos = { row : 0, column : 0}; 初始化函数中有一行代码将TextLayer中用于渲染text的dom容器必做canvas 123456789101112var textLayer = this.$textLayer = new TextLayer(this.content);this.canvas = textLayer.element;// layer/text.jsvar Text = function(parentEl) { this.dom = dom; this.element = this.dom.createElement(\"div\"); this.element.className = \"ace_layer ace_text-layer\"; parentEl.appendChild(this.element); this.$updateEolChar = this.$updateEolChar.bind(this); this.$lines = new Lines(this.element);}; TextLayer: layer/text查看Text的实现，会发现Text利用Lines来操作每一行，并且将ace_text-layer高度设置为很大。 123456789101112131415161718192021// layer/text.jsvar Text = function(parentEl) { this.dom = dom; this.element = this.dom.createElement(\"div\"); this.element.className = \"ace_layer ace_text-layer\"; parentEl.appendChild(this.element); this.$updateEolChar = this.$updateEolChar.bind(this); this.$lines = new Lines(this.element);};// layer/lines.jsvar Lines = function(element, canvasHeight) { this.element = element; // 将`ace_text-layer`高度设置为很大 this.canvasHeight = canvasHeight || 500000; this.element.style.height = (this.canvasHeight * 2) + \"px\"; this.cells = []; this.cellCache = []; this.$offsetCoefficient = 0;}; layer/lines.js中有一些对cells的增删查等操作，例如：get(index)、shift、pop、push、unshift，也有创建cell的函数。 12345678910111213141516171819this.createCell = function(row, config, session, initElement) { var cell = this.cellCache.pop(); if (!cell) { var element = dom.createElement(\"div\"); if (initElement) initElement(element); this.element.appendChild(element); cell = { element: element, text: \"\", row: row }; } cell.row = row; return cell;}; 这里注意到一个函数initElement函数，这个函数可能与渲染有关。lines.js本身没有调用createCell函数。text.js中只有一处调用了: 12345678910111213141516171819202122232425262728293031323334353637this.$renderLinesFragment = function(config, firstRow, lastRow) { var fragment = []; var row = firstRow; var foldLine = this.session.getNextFoldLine(row); var foldStart = foldLine ? foldLine.start.row : Infinity; while (true) { if (row &gt; foldStart) { row = foldLine.end.row+1; foldLine = this.session.getNextFoldLine(row, foldLine); foldStart = foldLine ? foldLine.start.row : Infinity; } if (row &gt; lastRow) break; // 这里没有传递initElement函数，我们看看renderLine函数 var line = this.$lines.createCell(row, config, this.session); var lineEl = line.element; this.dom.removeChildren(lineEl); dom.setStyle(lineEl.style, \"height\", this.$lines.computeLineHeight(row, config, this.session) + \"px\"); dom.setStyle(lineEl.style, \"top\", this.$lines.computeLineTop(row, config, this.session) + \"px\"); // Get the tokens per line as there might be some lines in between // beeing folded. this.$renderLine(lineEl, row, row == foldStart ? foldLine : false); if (this.$useLineGroups()) { lineEl.className = \"ace_line_group\"; } else { lineEl.className = \"ace_line\"; } fragment.push(line); row++; } return fragment;}; 实现渲染文本，大致上是通过$renderLine&gt;$renderSimpleLine&gt;$renderToken，通过$renderToken中调用dom.createTextNode来创建text节点。 1valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element)); 另外，在$renderToken函数中，对表意文字（中文、表情等）进行了正则匹配，表意文字的渲染是对每个文字都设置2个字符长度的宽度。 12345678} else if (cjk) { screenColumn += 1; var span = this.dom.createElement(\"span\"); span.style.width = (self.config.characterWidth * 2) + \"px\"; span.className = \"ace_cjk\"; span.textContent = cjk; valueFragment.appendChild(span);} CursorLayer:光标层这里有一点需要注意，ace几乎完美的实现了指哪显示哪。而在自己实现时，发现光标的位置在行首第一个字符前后比较难定位。为解决这个问题，才有了这篇文章。 光标效果实现不用多说，其采用css动画，配合setInterval来实现。 layer/cursor.js分析Cursor显示位置是通过getPixelPosition(position, onScreen)(onScreen为boolean型)函数来得到。 12345678910111213141516this.getPixelPosition = function(position, onScreen) { if (!this.config || !this.session) return {left : 0, top : 0}; if (!position) position = this.session.selection.getCursor(); var pos = this.session.documentToScreenPosition(position); var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth); var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight; return {left : cursorLeft, top : cursorTop};}; 函数执行过程中，大部分情况入参position为null，是从this.session.selection.getCursor()获取到了cursor所处的行列，这一点其实很重要：如何高精度命中行列。pos和position基本相同。计算cursorLeft又基本上是执行pos.column * this.config.characterWidth,其中characterWidth为7.201171875，为什么是这个数字？ 我们分析layer/font_metrics.js文件，发现了以下几行代码： 1234567891011121314151617181920212223242526272829303132333435var CHAR_COUNT = 256;this.$measureNode = dom.createElement(\"div\"); this.$setMeasureNodeStyles(this.$measureNode.style);this.$measureNode.textContent = lang.stringRepeat(\"X\", CHAR_COUNT); this.$characterSize = {width: 0, height: 0};this.checkForSizeChanges = function(size) { if (size === undefined) size = this.$measureSizes(); if (size &amp;&amp; (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) { this.$measureNode.style.fontWeight = \"bold\"; var boldSize = this.$measureSizes(); this.$measureNode.style.fontWeight = \"\"; this.$characterSize = size; this.charSizes = Object.create(null); this.allowBoldFonts = boldSize &amp;&amp; boldSize.width === size.width &amp;&amp; boldSize.height === size.height; this._emit(\"changeCharacterSize\", {data: size}); }};this.$measureSizes = function(node) { var size = { height: (node || this.$measureNode).clientHeight, width: (node || this.$measureNode).clientWidth / CHAR_COUNT }; // Size and width can be null if the editor is not visible or // detached from the document if (size.width === 0 || size.height === 0) return null; return size;}; 这里基本可以猜出，通过生成256个X字母来计算出每一个字符的宽度。查到dom，发现了一个dom，其宽度为1843.5，1843.5/256=7.201171875 光标指定行列那么还剩下：如何得到准确的行列?从上文中，我们得知是通过this.session.selection.getCursor()获取到行列。直接看selection.js中getCursor方法 123this.getCursor = function() { return this.lead.getPosition();}; 进一步发现了mouse/multi_select_handler中的onMouseDown方法。函数比较长，要慢慢分析。通过调试发现，点击操作该方法在第3个if判断中退出了。继续寻找，发现mouse/mouse_handler.js中存在对点击事件的绑定。 123456789101112131415var mouseTarget = editor.renderer.getMouseEventTarget();event.addListener(mouseTarget, \"click\", this.onMouseEvent.bind(this, \"click\"));event.addListener(mouseTarget, \"mousemove\", this.onMouseMove.bind(this, \"mousemove\"));var gutterEl = editor.renderer.$gutter;event.addListener(gutterEl, \"mousedown\", this.onMouseEvent.bind(this, \"guttermousedown\"));event.addListener(gutterEl, \"click\", this.onMouseEvent.bind(this, \"gutterclick\"));event.addListener(gutterEl, \"dblclick\", this.onMouseEvent.bind(this, \"gutterdblclick\"));event.addListener(gutterEl, \"mousemove\", this.onMouseEvent.bind(this, \"guttermousemove\"));...this.onMouseEvent = function(name, e) { this.editor._emit(name, new MouseEvent(e, this.editor));}; MouseEvent则来自mouse/mouse_event.js，但是并没有在其中找到gutterclick函数，mouse_event.js应该是对鼠标事件的重定义。 在mouse/fold_handler.js中找到对函数gutterclick事件的处理。gutter是编辑器左侧显示行号的那一列，点击则选中整行。同文件下的，click事件处理则是点击处理，来看看是否有我们需要的光标处理。 1234567891011121314151617181920212223editor.on(\"click\", function(e) { var position = e.getDocumentPosition(); var session = editor.session; // If the user clicked on a fold, then expand it. var fold = session.getFoldAt(position.row, position.column, 1); if (fold) { if (e.getAccelKey()) session.removeFold(fold); else session.expandFold(fold); e.stop(); } var target = e.domEvent &amp;&amp; e.domEvent.target; if (target &amp;&amp; dom.hasCssClass(target, \"ace_inline_button\")) { if (dom.hasCssClass(target, \"ace_toggle_wrap\")) { session.setOption(\"wrap\", !session.getUseWrapMode()); editor.renderer.scrollCursorIntoView(); } }}); 函数第一行便获取到了position，也就是行列。getDocumentPosition函数则是调用了virtual_renderer.js的screenToTextCoordinates函数 1234567891011121314151617181920this.screenToTextCoordinates = function(x, y) { var canvasPos; if (this.$hasCssTransforms) { canvasPos = {top:0, left: 0}; var p = this.$fontMetrics.transformCoordinates([x, y]); x = p[1] - this.gutterWidth - this.margin.left; y = p[0]; } else { canvasPos = this.scroller.getBoundingClientRect(); } var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding; var offset = offsetX / this.characterWidth; // 在调试时，this.$blockCursor基本上为false，所以col是四舍五入 var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset); var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight); return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);}; 所以，我们知道了是如何计算得到列的。那么，接下来，需要确认的是中文字符是如何确认列的。从dom的渲染来看，是将中文当成了2个英文字符。 用户输入首先发现的是一个隐藏的textarea 代码中明确增加事件监听的是： 123456// keyboard/textinput.jsevent.addListener(text, \"compositionstart\", onCompositionStart);event.addListener(text, \"compositionupdate\", onCompositionUpdate);event.addListener(text, \"keyup\", onKeyup);event.addListener(text, \"keydown\", syncComposition);event.addListener(text, \"compositionend\", onCompositionEnd); 创建编辑器会话：createEditSession(value)123456exports.createEditSession = function(text, mode) { var doc = new EditSession(text, mode); // 设置回撤管理器 doc.setUndoManager(new UndoManager()); return doc;}; EditSession123456789101112131415161718192021222324252627var EditSession = function(text, mode) { this.$breakpoints = []; this.$decorations = []; this.$frontMarkers = {}; this.$backMarkers = {}; this.$markerId = 1; this.$undoSelect = true; this.$foldData = []; this.id = \"session\" + (++EditSession.$uid); this.$foldData.toString = function() { return this.join(\"\\n\"); }; this.on(\"changeFold\", this.onChangeFold.bind(this)); this.$onChange = this.onChange.bind(this); if (typeof text != \"object\" || !text.getLine) text = new Document(text); this.setDocument(text); this.selection = new Selection(this); this.$bidiHandler = new BidiHandler(this); config.resetOptions(this); this.setMode(mode); config._signal(\"session\", this);}; EditSession(text, mode)这个函数做了很多工作，返回的EditSession包含属性doc。doc为Document类型。 初始化Document 从上图实例属性中看出doc.$lines默认包含一个空字符串元素 12345678910var Document = function(textOrLines) { this.$lines = [\"\"]; if (textOrLines.length === 0) { this.$lines = [\"\"]; } else if (Array.isArray(textOrLines)) { this.insertMergedLines({row: 0, column: 0}, textOrLines); } else { this.insert({row: 0, column:0}, textOrLines); }}; 其中insert函数是在指定的行列插入textOrLines。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990this.insert = function(position, text) { if (this.getLength() &lt;= 1) this.$detectNewLine(text); return this.insertMergedLines(position, this.$split(text));};this.getLength = function() { return this.$lines.length;};this.$detectNewLine = function(text) { var match = text.match(/^.*?(\\r\\n|\\r|\\n)/m); this.$autoNewLine = match ? match[1] : \"\\n\"; this._signal(\"changeNewLineMode\");};// 在position位置插入单行或多行，并返回结束位置this.insertMergedLines = function(position, lines) { // 获取正确的开始位置, 判断校正到正确的行列 var start = this.clippedPos(position.row, position.column); // 结束位置 var end = { row: start.row + lines.length - 1, column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length }; // 插入行 this.applyDelta({ start: start, end: end, action: \"insert\", lines: lines }); // 复制结束位置标记 return this.clonePos(end);};this.applyDelta = function(delta, doNotValidate) { var isInsert = delta.action == \"insert\"; if (isInsert ? delta.lines.length &lt;= 1 &amp;&amp; !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) { return; } if (isInsert &amp;&amp; delta.lines.length &gt; 20000) { this.$splitAndapplyLargeDelta(delta, 20000); } else { applyDelta(this.$lines, delta, doNotValidate); this._signal(\"change\", delta); }};exports.applyDelta = function(docLines, delta, doNotValidate) { var row = delta.start.row; var startColumn = delta.start.column; var line = docLines[row] || \"\"; switch (delta.action) { case \"insert\": var lines = delta.lines; // 插入单行 if (lines.length === 1) { docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn); } else { // 插入多行 var args = [row, 1].concat(delta.lines); docLines.splice.apply(docLines, args); docLines[row] = line.substring(0, startColumn) + docLines[row]; docLines[row + delta.lines.length - 1] += line.substring(startColumn); } break; case \"remove\": var endColumn = delta.end.column; var endRow = delta.end.row; if (row === endRow) { docLines[row] = line.substring(0, startColumn) + line.substring(endColumn); } else { docLines.splice( row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn) ); } break; }};this.onChangeNewLineMode = function() { this.$loop.schedule(this.CHANGE_TEXT); this.$textLayer.$updateEolChar(); this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);};","link":"/2020/02/17/ace-source-analysis/"},{"title":"ES2017中async&amp;await踩坑指南","text":"ES2017标准引入了async、await函数，使得异步操作变得更加方便了，而不用每次new Promise(...)了 本文还使用到了es6的其他特性，例如箭头函数=&gt;，以及不用说的Promise，所以为了在生产上兼容，需要引入babel-polyfill，并对代码进行Babel处理。这里暂时不对相关知识进行细说。如果你使用最新版的Chrome浏览器进行开发调试，就可以暂时不用关心相关知识了。 基本用法asyncasync其实是Promise语法糖。我们首先来写一个Promise： 1234567891011121314151617function asyncWork () { return new Promise((resolve, reject) =&gt; { // TODO something var isSucc = true if (isSucc) { reslove() } else { reject() } })}function doWrok () { asyncWork().then(resp =&gt; { console.log('success') })} 将其改为async写法： 123456789101112131415async function asyncWork () { // TODO something var isSucc = true if (isSucc) { return } else { throw 'error' }}function doWork () { asyncWork().then(resp =&gt; { console.log('success') })} 可以看到使用async语法糖后，asyncWork代码量减少了，特别是在代码逻辑比较复杂的时候，使用async会直观很多。 await往往使用await的函数需要使用async。 async表示异步，而await表示需要等待。进一步说，async函数可以看成将异步操作包装成一个Promise对象，而await就是then命令的语法糖。await使用方法： 12345678910111213141516171819202122async function asyncWork () { // TODO something var isSucc = true if (isSucc) { return } else { throw 'error' }}async function doWork () { // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() return workResult1 + workResult2}function mainWork() { doWrok.then(resp =&gt; { console.log(resp) })} 当然，也可以将上面的asyncWork方法改为使用Promise。 进阶踩坑既然使用了javaScript的ES2017特性，那么你一定会使用箭头函数=&gt;。相应的，在实际项目中，为了兼容性，我们会使用babel-preset-env等进行转义。坑来了，我们将上面的doWork方法改为如下： 12345678910async function doWork () { var array = [1, 2, 3] array.forEach(item =&gt; { // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) }) console.log(array)} 我们来创建两个文件index.html、main.js来进行验证: `index.html`: 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;async&amp;await&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;script src=\"./main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;&lt;/html&gt; `main.js` 1234567891011121314151617181920212223242526async function asyncWork () { // TODO something var isSucc = true if (isSucc) { return } else { throw 'error' }}async function doWork () { var array = [1, 2, 3] array.forEach(item =&gt; { // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) }) console.log(array)}function mainWork() { doWrok.then(resp =&gt; { console.log(resp) })} 这里，我们使用Pracel来进行打包。Parcel号称极速零配置Web应用打包工具，但是还是需要一点点配置的（当然也有一些限制），不过比那个vue-cli的webpack模板配置要简单多了!!! 使用npm init或者yarn init对项目初始化后，命令行运行：parcel index.html，运行结果： OMG!!!竟然报错了，什么情况？`async`、`await`这对鸳鸯成对出现了，怎么还会报错？！ 且慢，我们不妨看看`Parcel`对`doWork`的处理结果是什么。我们打开项目下的dist文件夹。dist文件夹下存放了`Parcel`的打包结果。 ... 哈哈，竟然只有`index.html`文件。那我们上述`doWork`函数改一下： 12345678910async function doWork () { var array = [1, 2, 3] for (var i = 0; i &lt; array.length; i++) { // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) } console.log(array)} 再次运行`parcel index.html`，编译成功： 机智的我们发现是箭头`=>`函数在添乱。我们再看一下es6中`=>`的定义： 123456var f = v =&gt; v;// 等同于var f = function (v) { return v;}; 那上面包含箭头函数的`doWork`也就等同于： 12345678910async function doWork () { var array = [1, 2, 3] array.forEach(function(item) { // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) }) console.log(array)} 外层的`doWork`函数和包裹await的函数已经不是同一个函数了，所以`Parcel`编译失败。如果想继续使用箭头函数，可以改为： 12345678910function doWork () { var array = [1, 2, 3] array.forEach(async(item) =&gt; { // 将等待两个asyncWork的返回结果，然后执行下一步 var workResult1 = await asyncWork() var workResult2 = await asyncWork() console.log(workResult1 + workResult2) }) console.log(array)} 所以，`async`、`await`、`=>`等es6特性，在使用时要注意它们的作用，避免增加不必要的调试时间。","link":"/2018/05/10/async-and-await-comprehensive-guide/"},{"title":"canvas文本高度","text":"多看官方文档，拨云见日 在使用canvas绘制文本的时候，我们可能会需要知道文本的宽高，来达到给文本增加边框，或者确定相对位置。下面我们来一步步实现一个在文本绘制边框的例子。 初始化初始化canvas,首先在html中插入一个canvas节点。 1&lt;canvas id=\"canvas\" style=\"width: 100%;\"&gt;&lt;/canvas&gt; 在绘图前，我们应该先设置分辨率，否则会糊。 先不设置分辨率，直接绘制canvas text 12345function draw() { var ctx = document.getElementById('canvas').getContext('2d'); ctx.font = \"40px serif\"; ctx.fillText(\"canvas text\", 10, 50);} 得到的效果是 设置分辨率主要是设置canvas的宽高。 12345678910111213141516171819var fontSize = 40var dpr = window.devicePixelRatio || 1/** * 设置分辨率 */function initPixel () { var canvas = document.getElementById('canvas') canvas.width = canvas.width * dpr canvas.height = canvas.height * dpr var ctx = canvas.getContext('2d'); ctx.scale(dpr, dpr)}function draw() { var ctx = document.getElementById('canvas').getContext('2d'); ctx.font = fontSize + \"px serif\"; var text = \"canvas text\" ctx.fillText(text, 10, 50);} 设置分辨率后的文字更清晰。 绘制边框绘制边框，首先我们需要知道文本的宽高（假设文本只占一行）。文本的宽度我们很容易得到，通过CanvasRenderingContext2D.measureText来得到文字的宽高。 1var textMetrics = ctx.measureText(\"canvas text\"); 得到的TextMetrics包含了很多信息，根据其中一些属性可以得到文本的宽高，例如：TextMetrics.width, TextMetrics.fontBoundingBoxAscent, TextMetrics.fontBoundingBoxDescent，我们的目标主要就是得到宽高，现在都能得到了，这也太简单了，那画简单的矩形就更不用讲了，心疼本文结束。 继续滑动页面，查看TextMetrics的其他描述，突然看到了浏览器兼容性 两个可以计算出文本高度的属性TextMetrics.fontBoundingBoxAscent, TextMetrics.fontBoundingBoxDescent还只是实验功能，很多浏览器不支持。 所以，继续，我们基本只能通过TextMetrics得到文本的宽度，也就是TextMetrics.width。那么如何得到绘制文本的高度呢？ 误入歧途查看文档，搜索例子，均未得到结果。想到前些天分析ace.js富文本代码编辑的源码，可以通过DOM渲染文本，从而得到文本的高度。 1&lt;div class=\"measure\" style=\"font-size: 40px;font-family: serif;\"&gt;canvas text&lt;/div&gt; 首先获取.measure DOM的高度，由于设置分辨率的时候进行了放大操作，而DOM是没有进行放大设置的，所以这里传给canvas的高度要进行相应缩小。 123456function strokeTextRect(ctx, text) { var textMetrics = ctx.measureText(text); var height = document.querySelector('.measure').clientHeight / dpr ctx.strokeStyle = 'red'; ctx.strokeRect(10, 50 - height, textMetrics.width, height);} 这样得到的边框效果如下 边框有点高。给.measure DOM设置line-height: 1&lt;div class=\"measure\" style=\"font-size: 40px;font-family: serif;line-height: 40px;\"&gt;canvas text&lt;/div&gt; 边框的高度变小了 font-size和line-height之间有什么联系吗？ 正道查询一系列关于font-size介绍的中文文档，均是字体大小，这个大小是指宽？还是指字体的高？ 查询W3C草案，被自己浅薄的知识震惊到。 This property indicates the desired height of glyphs from the font.此属性指示所需的字体字形高度。—有道词典 font-size是文本的高度。本文结束。 完整例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;canvas text height&lt;/title&gt; &lt;style&gt; body, html { margin: 0; } .measure { /* position: absolute; */ top: 300px; left: 10px; word-break: keep-all; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;canvas id=\"canvas\" style=\"width: 100%;\"&gt;&lt;/canvas&gt; &lt;div class=\"measure\" style=\"font-size: 40px;font-family: serif;line-height: 40px;\"&gt;canvas text&lt;/div&gt; &lt;/div&gt; &lt;script&gt; var fontSize = 40 var dpr = window.devicePixelRatio || 1 // var dpr = 1 function initPixel () { var canvas = document.getElementById('canvas') console.log('canvas', canvas.width, canvas.height, dpr) canvas.width = canvas.width * dpr canvas.height = canvas.height * dpr var ctx = canvas.getContext('2d'); ctx.scale(dpr, dpr) } function draw() { var ctx = document.getElementById('canvas').getContext('2d'); ctx.font = \"40px serif\"; var text = \"canvas text\" ctx.fillText(text, 10, 50); strokeTextRect(ctx, text) } function strokeTextRect(ctx, text) { var textMetrics = ctx.measureText(text); var height = document.querySelector('.measure').clientHeight / dpr // height = fontSize / dpr // dpr = 1 ctx.strokeStyle = 'red'; ctx.strokeRect(10, 50 - height, textMetrics.width, height); } window.onload = () =&gt; { initPixel() draw() } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/05/12/canvas-text-height/"},{"title":"组件库技术分析：vant","text":"Vant是一个不错的开源vue组件库。对其进行技术分析，来学习它是如何实现一系列特性。 dev开发模式vant采用了vant-cli dev命令来运行开发模式。 vant-cli在vant源码packages文件夹下。 12345// `vant-cli`的package.json中：\"scripts\": { \"dev\": \"tsc --watch\", \"release\": \"tsc &amp; release-it\"} tsc --watch监视目录内文件变化，并将编译后文件输出到lib文件夹下。 vant-cli:devvant-cli/src/index.ts中使用commander注册了很多运行命令，其中dev命令： 12// vant-cli/src/index.tsimport { dev } from './commands/dev'; 1234567// ./commands/dev.tsimport { compileSite } from '../compiler/compile-site';export async function dev() { setNodeEnv('development'); await compileSite();} ../compiler/compile-site.ts中使用到了一系列的node.js工具库，分别是： chalk: 使node.js命令终端输出内容多彩 address: 获取当前机器的IP, MAC and DNS服务器 webpack: 如果webpack上市，那一定要买它 webpack-dev-server: webpack所属的dev服务库，支持自动重载 lodash:get: get(object, path, [defaultValue]) 根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。 例如这里的：const host = get(config.devServer, 'host', 'localhost'); portfinder:getPort: 获取本机可用端口 1234567891011121314151617181920212223242526272829303132333435363738394041// ../compiler/compile-site.ts 主要内容...import { getSiteDevConfig } from '../config/webpack.site.dev';...function runDevServer( port: number, config: ReturnType&lt;typeof getSiteDevConfig&gt;) { const server = new WebpackDevServer(webpack(config), config.devServer); // this is a hack to disable wds status log (server as any).showStatus = function () {}; const host = get(config.devServer, 'host', 'localhost'); server.listen(port, host, (err?: Error) =&gt; { if (err) { console.log(err); } });}function watch() { const config = getSiteDevConfig(); getPort( { port: config.devServer!.port, }, (err, port) =&gt; { if (err) { console.log(err); return; } logServerInfo(port); runDevServer(port, config); } );}... ../compiler/compile-site.ts主要是获取webpack配置，然后通过WebpackDevServer启动服务。 ../config/webpack.site.dev.ts主要内容： 获取vant-cli/src/config/webpack.base.ts配置； 获取vant项目根目录的webpack.config.js配置； 上述二次webpack配置，结合webpack.site.dev.ts的webpack配置，三处配置合并。 vant-cli/src/config/webpack.base.ts分析webpack.base.ts主要是完成了development模式设定，vue\\js\\ts\\css等资源的解析和加载。 resolve.extensions确定了解析的文件类型：js\\jsx\\vue\\ts\\tsx和css\\less\\scss; vue类型的文件，使用vue-loader解析; babel-loader解析/\\.(js|ts|jsx|tsx)$/ markdown类型的文件使用@vant/markdown-loader解析，将markdown格式内容转换为vue组件。另外使用cache-loader,对性能开销较大的 loader 使用此 loader,将结果缓存到磁盘里 @nuxt/friendly-errors-webpack-plugin:识别webpack错误的某些类别，并清理、聚合和排序它们，以提供更好的开发人员体验 css\\less\\scss样式文件处理 css 12345{ test: /\\.css$/, sideEffects: true, use: CSS_LOADERS,} sideEffects在webpack的解释： A “side effect” is defined as code that performs a special behavior when imported, other than exposing one or more exports. 基本意思是：sideEffects设置为true，则不导出exports 1234567891011// CSS_LOADERSconst CSS_LOADERS = [ 'style-loader', 'css-loader', { loader: 'postcss-loader', options: { postcssOptions: require(POSTCSS_CONFIG_FILE), }, },]; 对于css类型文件，采用分别使用postcss-loader、css-loader、style-loader处理。 其中postcss-loader配置引用config目录下的postcss.config.js 1234...export const CONFIG_DIR = join(__dirname, '../config');...export const POSTCSS_CONFIG_FILE = join(CONFIG_DIR, 'postcss.config.js'); less 12345{ test: /\\.less$/, sideEffects: true, use: [...CSS_LOADERS, 'less-loader'],} less-loader接CSS_LOADERS。 scss 123456789101112131415import sass from 'sass';...{ test: /\\.scss$/, sideEffects: true, use: [ ...CSS_LOADERS, { loader: 'sass-loader', options: { implementation: sass, }, }, ],} plugins分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849...import { VueLoaderPlugin } from 'vue-loader';...const plugins = [ new webpack.DefinePlugin({ __VUE_OPTIONS_API__: 'true', __VUE_PROD_DEVTOOLS__: 'false', }), new VueLoaderPlugin(), new FriendlyErrorsPlugin({ clearConsole: false, logLevel: 'WARNING', }),];...// 方法会返回 Node.js 进程的当前工作目录export const CWD = process.cwd();...const tsconfigPath = join(CWD, 'tsconfig.json');if (existsSync(tsconfigPath)) { const ForkTsCheckerPlugin = require('fork-ts-checker-webpack-plugin'); plugins.push( new ForkTsCheckerPlugin({ typescript: { extensions: { vue: { enabled: true, compiler: '@vue/compiler-sfc', }, }, }, logger: { issues: { // skip info message log() {}, warn(message: string) { consola.warn(message); }, error(message: string) { consola.error(message); }, }, }, }) );} 在解析typescript时，使用到了webpack推荐的fork-ts-checker-webpack-plugin,以此提高性能 To improve the build time when using ts-loader, use the transpileOnly loader option. On its own, this option turns off type checking. To gain type checking again, use the ForkTsCheckerWebpackPlugin. This speeds up TypeScript type checking and ESLint linting by moving each to a separate process. fork-ts-checker-webpack-plugin中设置了vue单文件的解释器为@vue/compiler-sfc，将vue单文件组件解析为js代码，英文解释： This package contains lower level utilities that you can use if you are writing a plugin / transform for a bundler or module system that compiles Vue Single File Components (SFCs) into JavaScript. It is used in vue-loader, rollup-plugin-vue and vite. @vue/compiler-sfc又涉及到了vue-loader，网上一篇文章有介绍1.vue-loader如何实现.vue的处理(vue3.0版本)。 cache分析 缓存生成的 webpack 模块和 chunk，来改善构建速度。 12345678910cache: { // type有两种值：'memory' | 'filesystem' // memory 选项很简单，它会告诉 webpack 将内容存放在内存中并且不允许额外的配置 type: 'filesystem', // buildDependencies 是用于构建的额外代码依赖数组。webpack 将使用这些项和所有依赖项的哈希值来使文件系统缓存失效。 buildDependencies: { // 推荐在你的 webpack 配置中设置 cache.buildDependencies.config: [__filename] 以获取最新配置以及所有依赖项。 config: [__filename], },} vant项目根目录的webpack.config.js配置12345678910111213141516171819202122const { join } = require('path');module.exports = function () { // 打包发布状态下，不配置内容 if (process.env.BUILD_TARGET === 'package') { return {}; } return { devtool: false, entry: { // 新增site-mobile入口 // site-mobile在webpack.site.dev.ts中定义 'site-mobile': ['./docs/site/mobile'], }, resolve: { alias: { // 增加解析路径别名@demo解析道docs/site '@demo': join(__dirname, 'docs', 'site'), }, }, };}; vant-cli/src/config/webpack.site.dev.ts分析该配置文件使用到的工具库有： webpackbar：webpack编译进度条 html-webpack-plugin: 用于创建html文件，来加载编译后的js文件 lodash:get: get(object, path, [defaultValue]) 根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。 例如这里的：const host = get(config.devServer, 'host', 'localhost'); path.join(): 方法会将所有给定的 path 片段连接到一起（使用平台特定的分隔符作为定界符），然后规范化生成的路径。 webpack-merge.merge():方法将会‘concatenates arrays and merges objects creating a new object’，合并数组和多个对象并创建新对象。 compiler/compile-site.ts文件主要引用了webpack.site.dev.ts的getSiteDevConfig方法：import { getSiteDevConfig } from '../config/webpack.site.dev';。 123456...import { getVantConfig, getWebpackConfig } from '../common';...export function getSiteDevConfig(): WebpackConfig { return getWebpackConfig(getSiteDevBaseConfig());} getWebpackConfig(defaultConfig: WebpackConfig)主要是获取vant根目录的webpack.config.js的配置内容，并将其与defaultConfig配置合并，也就是与getSiteDevBaseConfig()配置合并。 getSiteDevBaseConfig()主要是获取vant.config.js的配置，并根据defaultLang设置站点的配置。 重点看看plugins配置： 123456789101112131415161718192021222324252627plugins: [ new WebpackBar({ name: 'Vant Cli', color: GREEN, }), new VantCliSitePlugin(), new HtmlWebpackPlugin({ title, logo: siteConfig.logo, description: siteConfig.description, chunks: ['chunks', 'site-desktop'], template: join(__dirname, '../../site/desktop/index.html'), filename: 'index.html', baiduAnalytics, ...htmlPluginOptions, }), new HtmlWebpackPlugin({ title, logo: siteConfig.logo, description: siteConfig.description, chunks: ['chunks', 'site-mobile'], template: join(__dirname, '../../site/mobile/index.html'), filename: 'mobile.html', baiduAnalytics, ...htmlPluginOptions, }),] VantCliSitePlugin分析自定义插件。使用到的第三方库： fs-extra: 提供了很多fs库不支持的功能，例如读写文件等。这里使用到了outputFileSync(...)函数，将内容写入文件。 插件在watchRun和beforeCompile阶段执行genSiteEntry()函数。 123456789export class VantCliSitePlugin { apply(compiler: Compiler) { if (process.env.NODE_ENV === 'production') { compiler.hooks.beforeCompile.tapPromise(PLUGIN_NAME, genSiteEntry); } else { compiler.hooks.watchRun.tapPromise(PLUGIN_NAME, genSiteEntry); } }} watchRun: 在监听模式下，一个新的 compilation 触发之后，但在 compilation 实际开始之前执行。 beforeCompile: 在创建 compilation parameter 之后执行。 tapPromise: 用来注册和调用插件，描述可见Tapable. genSiteEntry()函数主要是在vant-cli包的dist目录下生成下列文件： package-entry.js: 同时存在export { install, version, ...Card...}和export default { install, version} package-style.less: 所有组件的less文件引用。例如：@import &quot;/***/***/***/vant/src/style/base.less&quot;; site-desktop-shared.js: vant.config.js引用和所有组件的README.md文件引用。 import config from '/Users/gtja/Projects/vant/vant.config'; import Tag_en_US from '/Users/gtja/Projects/vant/src/tag/README.md'; site-mobile-shared.js: 所有组件demo入口的引用 import Card from '/Users/gtja/Projects/vant/src/card/demo/index.vue'; style-deps.json: (这个文件不是genSiteEntry()生成)包含了组件依赖关系，例如&quot;button&quot;: [ &quot;info&quot;, &quot;icon&quot;, &quot;loading&quot; ], button直接引用了icon、loading组件，而icon引用了info组件。 vant-cli:dev总结我们来总结一下dev整体逻辑： 两个入口文件：site-desktop和site-mobile 'site-desktop': [join(__dirname, '../../site/desktop/main.js')] 'site-mobile': [join(__dirname, '../../site/mobile/main.js')] 加载两种html文件：site/desktop/index.html和site/mobile/index.html index.html mobile.html 页面首次加载index.html,在路由中增加了判断是否为移动端，从而替换为mobile.html 12345// vant-cli/site/desktop/router.jsimport { isMobile, decamelize } from '../common';if (isMobile) { location.replace('mobile.html' + location.hash);} 12// vant-cli/site/common/index.jsconst isMobile = /ios|iphone|ipod|ipad|android/.test(ua); vant-cli/site/desktop/router.js通过引入site-desktop-shared.js的documents，加载了一系列的组件README.md文件 vant-cli:releaserelease命令：tsc &amp; release-it。 release-it Generic CLI tool to automate versioning and package publishing related tasks 版本控制和执行发包任务。这个主要是vant-cli发布。我们来看看vant发布命令执行 vant根目录运行release命令，执行流程： &quot;release&quot;: &quot;vant-cli release&quot; vant-cli/src/index.ts中运行release命令 执行'./commands/release'中release函数 利用release-it执行release-it插件：/compiler/vant-cli-release-plugin.js vant-cli-release-plugin.js分别执行'../commands/build';和'../commands/changelog'; release:'../commands/build';build构建主要第三方库： chokidar: 监控文件变化 fs-extra: 文件操作库 execa：Process execution for humans 执行命令 @babel/core: 使用transformAsync处理js代码字符串 clean-css: 用于压缩css代码（clean-css is a fast and efficient CSS optimizer for Node.js platform and any modern browser.） build函数逻辑： 设置node运行环境为production clean:删除es\\lib\\dist\\vetur\\site文件夹 通过execa安装依赖 依次构建任务： buildEs: 设置@babel/preset-env的modules为false，也就是保持为esmodule 将src文件夹内容，拷贝到es文件夹 编译es文件夹内非demo和非test文件。其使用readdirSync读取文件夹目录，lstatSync(dir).isDirectory()判断是目录还是文件，是目录则递归编译。 编译文件compileFile函数，正则判断文件/\\.(vue)$/，如果是单文件组件，则执行compiler/compile-sfc.ts中compileSfc函数。compileSfc函数很有意思，它首先执行了异步remove删除vue文件，然后执行同步readFileSync读文件操作，让人误认为先删除后又去读取，实际的执行是先执行同步的readFileSync函数，后执行删除操作。 buildLib： 设置@babel/preset-env的modules为’commonjs’ 后续逻辑通buildEs buildStyleEntry genStyleDepsMap 获取所有组件，遍历的文件类型：['js', 'ts', 'tsx', 'jsx', 'vue']，并且文件中包含code.includes('export default') || code.includes('export { default }')才会被识别为组件。 清空deps缓存 使用typescript的Record&lt;string, string[]&gt;类型存储DepsMap 分析每一个组件的Deps genComponentStyle: buildPacakgeEntry buildPackages compiler/compile-sfc.ts文件说明compileSfc函数说明： 读取vue单文件组件 parseSfc: 使用@vue/component-compiler-utils和vue-template-compiler解析vue文件 1234567891011121314import * as compiler from 'vue-template-compiler';import * as compileUtils from '@vue/component-compiler-utils';...export function parseSfc(filePath: string) { const source = readFileSync(filePath, 'utf-8'); const descriptor = compileUtils.parse({ source, compiler, needMap: false, } as any); return descriptor;} vue-template-compiler: This package can be used to pre-compile Vue 2.0 templates into render functions to avoid runtime-compilation overhead and CSP restrictions. In most cases you should be using it with vue-loader, you will only need it separately if you are writing build tools with very specific needs. @vue/component-compiler-utils: This package contains lower level utilities that you can use if you are writing a plugin / transform for a bundler or module system that compiles Vue single file components into JavaScript. It is used in vue-loader version 15 and above. parseSfc利用@vue/component-compiler-utils.parse方法解析单文件内容得到descriptor,从descriptor中分别获取属性template、styles，通过判断styles是否是scoped，从而依据单文件内容的hash值来生成scopedId 将styles按编号生成${filePath(单文件)}-sfc${number}.css的文件路径名 使用path.parse获取到上述css文件名称，拼接为字符串import './css文件名';，多个style拼接为imports变量字符串 将descriptor的script中内容EXPORT（'export default {'）替换为${imports}\\n\\n${EXPORT}。（这里有一个疑问，css的文件并没有看到哪里有逻辑生成，为什么这里会直接拼接入script？） 利用@vue/component-compiler-utils.compileTemplate将template.content编译为render.code函数代码 将render.code中的'var render'字符替换为'var __vue_render__'，'var staticRenderFns'字符替换为'var __vue_staticRenderFns__'，将render.code插入script的'export default {'字符前面，并在'export default {'中追加导出：render和staticRenderFns两个函数，两函数分别赋值为前面的__vue_render__和__vue_staticRenderFns__。 插入scopeId: script中export default {增加_scopeId: '${scopeId}'属性字符串 将处理好的script字符串写入单文件名对应descriptor.script.lang || 'js'类型文件中 compiler/compile-js.ts对上述处理好的script进行处理： replaceCssImportExt: “import ‘a.less’;” =&gt; “import ‘a.css’;” 利用正则匹配import：const IMPORT_STYLE_RE = /import\\s+?(?:(?:”.?”)|(?:’.?’))[\\s]*?(?:;|$|)/g; replaceScriptImportExt: 转义’.vue’的import为’’，例如：”import App from ‘App.vue’;” =&gt; “import App from ‘App’;” transformAsync: 使用@babel/core对js进行编译，删除编译前的文件，并将编译后的代码保存为js文件 编译styles，利用@vue/component-compiler-utils编译styles中每一个style内容，并保存到上文中我们对css文件的疑问地址 按不同样式文件，分别使用less的render\\FileManager和sass的renderSync编译less与scss类型的文件，得到css字符串。 使用postcss-load-config获取postcss配置,利用postcss编译上述css字符串。 使用clean-css压缩postcss编译后的css代码 release:changelog打印日志","link":"/2021/02/13/component-lib-technology-analysis-vant/"},{"title":"Facebook:使用高性能的开源TLS库Fizz大规模部署TLS1.3","text":"翻译自：原文 新一代传输层安全协议TLS1.3增加了几项新功能，可以使互联网流量更加安全，包括加密握手消息以保证证书私密，重新设计密钥的派生方式，以及零往返连接设置，这使得某些请求比TLS1.2快。每天有超过10亿人使用Facebook与他们的朋友和家人联系，正是TLS1.3将他们的数据从应用程序传输到我们的服务器（然后，我们把数据提供给别人…最近用户隐私把Facebook折腾的够呛）。为了在Facebook上实现TLS1.3，我们创建了Fizz：一个用C++14编写的强大、高性能的TLS库。除了TLS1.3附带的协议增强功能外，Fizz还提供了许多功能，包括默认支持异步I/O，以及分散和收集I/O以消除对额外数据副本的需求。 我们现在已经在我们的移动应用程序Proxygen、负载均衡器、内部服务，甚至我们的QUIC库mvfst中全局部署了Fizz和TLS1.3。现在，Facebook超过50%的互联网流量使用了TLS1.3进行保护。在我们的移动应用程序上部署了TLS1.3的新特性：0个RTT发送数据。Fizz现在每秒处理数百万次TLS1.3握手。我们相信这使Fizz成为互联网上TLS1.3和0-RTT往返数据的最大部署。Fizz不仅减少了延迟，还减少了每天执行数万亿请求的服务器CPU的使用率。我们很高兴能够开源Fizz，以帮助加速在互联网上部署TLS1.3，并帮助其他人使他们的应用和服务更快、更安全。 性能我们的团队与互联网工程任务组（IETF）合作多年，致力于标准化TLS1.3。以前，为了提高TLS的安全性和性能，我们部署了Zero协议。这是一种私有协议，允许我们尝试建立0-RTT安全连接。使用0-RTT数据可减少使用TLS的请求延迟以及部署TLS所需的延迟开销。Fizz提供与Zero洗衣相同的TLS1.3的可靠性和性能，因此我们使用TLS1.3取代了我们的Zero协议部署。 性能也是Fizz关注的重点。通过零拷贝加解密，与我们基础架构的其他部分紧密集成以及其他优化，我们发现Fizz减少了内存和CPU的占用率。我们的负载均衡器综合基准测试显示，吞吐量比我们之前的堆栈高出约10%，但是我们不会骄傲，我们将会继续致力于提供Fizz性能。 通Zero协议一样，相比于TLS1.2，TLS1.3在握手阶段建立安全连接时显著减少了延迟。这样可以改善用户体验，尤其是在没有可重用连接的时候，比如应用程序启动时。 减少延迟的百分比（TLS1.3与TLS1.2在建立连接时） 默认异步在TLS的现代部署中，服务器遍布全球。TLS负载均衡器位于一个位置是常见的，而TLS证书签名密钥由位于世界各地的另一个安全服务提供。像无密钥SSL（更像是一种拆分握手过程，私钥解密在一台服务器上，其他步骤可以在其他服务器上完成）之类的技术，被运用到将加密计算分发到不同的主机。 由于服务器通常希望能够在握手过程中能够调用其他服务，因此异步IO变得非常重要。当我们在编写Fizz时，我们希望将多个功能拆解到其他远程的服务器上，例如证书操作。因此，Fizz服务默认情况下是异步的。我们利用futures来提供一个简单的异步API，来自Fizz的任何回调都可以异步相应，而不会阻止服务处理其他握手。对于其他用例，向Fizz添加新的异步回调也非常容易。 零拷贝写多个库中的TLS APIs要求用户提供连续的内存块。TLS库加密连续内存块中的数据并将其写入socket中。然后，应用程序通常以不同存储器位置中的几个数据块的形式将数据保存在存储器中，而不是存储在一个连续的存储器块中。在其他库中，应用程序需要将数据拷贝到连续的内存位置，以便将其提供给TLS库。此复制操作会增加延迟开销。Fizz拥有支持分散、聚合I/O的API，其所有API都默认接受分散、聚合的抽象作为输入。这允许用户传入分块数据，然后Fizz将数据加密到分块内存中，从而避免了复制数据的需要。因此，使用Fizz的应用程序执行的内存分配和副本更少，这是高性能应用程序的一个重要考虑因素。","link":"/2018/08/22/facebook-Fizz/"},{"title":"快速加载的响应式图片","text":"参考文章","link":"/2020/05/13/faster-and-responsive-images/"},{"title":"ES6:看不懂的let类型与闭包间的关系+Babel的bug","text":"let是ES6变量类型，其只在代码块内有效。闭包是有函数以及创建该函数的词法环境组合而成，这个环境包含了这个闭包创建时所能访问的所有局部变量。 如果合理使用闭包，可以使用var实现let局部有效的效果。显然这是多余的，因为babel已经能帮我们做了，并且很多新版浏览器都支持let，所有本文结束。 等等，babel都干了啥？为啥能将let转码使代码兼容旧版浏览器？ 兼容转码我们先来看一段比较简单的babel转码 我们来搬一段特别复杂的let类型申明代码 code11234567var a = [];for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); };}a[6](); // 6 在babel官网将其转码为兼容代码： code21234567891011121314\"use strict\";var a = [];var _loop = function _loop(i) { a[i] = function () { console.log(i); };};for (var i = 0; i &lt; 10; i++) { _loop(i);}a[6](); // 6 老司机马上就看出了：将let转为了闭包 闭包我们来看看MDN上的一段例子 code312345678910function makeFunc() { var name = \"Mozilla\"; function displayName() { alert(name); } return displayName;}var myFunc = makeFunc();myFunc(); 闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。我们一通分析便可以看出code3闭包的基本结构： code412345function (j) { return function () { console.log(j) }}(i) code4的闭包是立即执行 利用闭包，使var == letcode4的结构不正是code2的简写吗？我们可以将code2改写为： code5123456789101112\"use strict\";var a = [];for (var i = 0; i &lt; 10; i++) { a[i] = function (j) { return function () { console.log(j) } }(i)}a[6](); // 6 说好的简写呢？！仔细阅读这句话闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。 let是块级作用域，也就是局部作用域。闭包也是能访问局部作用域。 code4正是将变量i赋值给函数的局部变量j，code5中数组a的每个item都是该函数实例的引用。在let出现之前，在循环中写闭包是一个比较常见的问题。 我们不鼓励在循环中创建闭包，过多的闭包会付出性能代价。 Babel的bug意外发现了一个Babel的小bug。我们在最新的Chrome/Firefox浏览器中运行这段代码： code61234for (let i = 0; i &lt; 3; i++) { let i = 'abc'; console.log(i, new Date().getTime());} 会发现输出结果为3次”abc 1539160907***”。将code6通过Babel转码得到code7 code71234for (var i = 0; i &lt; 3; i++) { var i = 'abc'; console.log(i, new Date().getTime());} code7在浏览器中仅仅运行了1次，输出结果为”abc 1539160907***” 阮老师讲： for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。","link":"/2018/10/10/es6-let-closure/"},{"title":"echarts candlestick图表源码分析","text":"echarts candlestick图表源码分析 前言：echarts源码入口：src/echarts.js 12345678910111213export function init(dom, theme, opts) { ... // Echarts中初始化了zrender var chart = new ECharts(dom, theme, opts); chart.id = 'ec_' + idBase++; instances[chart.id] = chart; modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id); enableConnect(chart); return chart;} Echarts(dom, theme, opts)中初始化zrender： 123456var zr = this._zr = zrender.init(dom, { renderer: opts.renderer || defaultRenderer, devicePixelRatio: opts.devicePixelRatio, width: opts.width, height: opts.height}); 我们通过echarts.setOption来呈现图表。 1234567891011121314151617181920212223242526272829303132333435363738var echartsProto = ECharts.prototype;.../** * Usage: * chart.setOption(option, notMerge, lazyUpdate); * chart.setOption(option, { * notMerge: ..., * lazyUpdate: ..., * silent: ... * }); * * @param {Object} option * @param {Object|boolean} [opts] opts or notMerge. * @param {boolean} [opts.notMerge=false] * @param {boolean} [opts.lazyUpdate=false] Useful when setOption frequently. */echartsProto.setOption = function (option, notMerge, lazyUpdate) { ... // 存储合并options this._model.setOption(option, optionPreprocessorFuncs); ... // 准备 prepare(this); // 执行render(ecIns, ecModel, api, payload)函数 updateMethods.update.call(this); // Ensure zr refresh sychronously, and then pixel in canvas can be // fetched after `setOption`. this._zr.flush(); this[OPTION_UPDATED] = false; this[IN_MAIN_PROCESS] = false; flushPendingActions.call(this, silent); triggerUpdatedEvent.call(this, silent);}; 1234567891011121314151617181920var updateMethods = { ... /** * @param {Object} payload * @private */ update: function (payload) { // console.profile &amp;&amp; console.profile('update'); var ecModel = this._model; var api = this._api; var zr = this._zr; var coordSysMgr = this._coordSysMgr; var scheduler = this._scheduler; ... render(this, ecModel, api, payload); ... // console.profile &amp;&amp; console.profileEnd('update'); }} render(ecIns, ecModel, api, payload)函数中分别渲染component和series 12345678910111213141516function render(ecIns, ecModel, api, payload) { renderComponents(ecIns, ecModel, api, payload); each(ecIns._chartsViews, function (chart) { chart.__alive = false; }); renderSeries(ecIns, ecModel, api, payload); // Remove groups of unrendered charts each(ecIns._chartsViews, function (chart) { if (!chart.__alive) { chart.remove(ecModel, api); } });} 1234567891011121314151617181920212223242526272829303132333435/** * Render each chart and component * @private */function renderSeries(ecIns, ecModel, api, payload, dirtyMap) { // Render all charts var scheduler = ecIns._scheduler; var unfinished; ecModel.eachSeries(function (seriesModel) { var chartView = ecIns._chartsMap[seriesModel.__viewId]; chartView.__alive = true; var renderTask = chartView.renderTask; scheduler.updatePayload(renderTask, payload); if (dirtyMap &amp;&amp; dirtyMap.get(seriesModel.uid)) { renderTask.dirty(); } unfinished |= renderTask.perform(scheduler.getPerformArgs(renderTask)); chartView.group.silent = !!seriesModel.get('silent'); updateZ(seriesModel, chartView); updateBlend(seriesModel, chartView); }); scheduler.unfinished |= unfinished; // If use hover layer updateHoverLayerStatus(ecIns, ecModel); // Add aria aria(ecIns._zr.dom, ecModel);} TODO 分析updateMethods。 有点迷失，先分析zrender。 12345678910// new Echarts中初始化this._zrvar zr = this._zr = zrender.init(dom, { renderer: opts.renderer || defaultRenderer, devicePixelRatio: opts.devicePixelRatio, width: opts.width, height: opts.height});// 而后，在setOption中调用this._zr.flush() 12345678910111213141516171819202122232425262728293031323334flush: function () { var triggerRendered; if (this._needsRefresh) { triggerRendered = true; this.refreshImmediately(); } if (this._needsRefreshHover) { triggerRendered = true; this.refreshHoverImmediately(); } triggerRendered &amp;&amp; this.trigger('rendered');}.../*** Repaint the canvas immediately*/refreshImmediately: function () { // var start = new Date(); // Clear needsRefresh ahead to avoid something wrong happens in refresh // Or it will cause zrender refreshes again and again. this._needsRefresh = this._needsRefreshHover = false; this.painter.refresh(); // Avoid trigger zr.refresh in Element#beforeUpdate hook this._needsRefresh = this._needsRefreshHover = false; // var end = new Date(); // var log = document.getElementById('log'); // if (log) { // log.innerHTML = log.innerHTML + '&lt;br&gt;' + (end - start); // }} 引用链入口echarts.all.js import './src/chart/candlestick';。 candlestick/src/chart/candlestick.js 123456789101112import * as echarts from '../echarts';import './candlestick/CandlestickSeries';import './candlestick/CandlestickView';import preprocessor from './candlestick/preprocessor';import candlestickVisual from './candlestick/candlestickVisual';import candlestickLayout from './candlestick/candlestickLayout';echarts.registerPreprocessor(preprocessor);echarts.registerVisual(candlestickVisual);echarts.registerLayout(candlestickLayout); 解析先从最简单的说起echarts.js初始化函数： 12345678910111213141516var instances = {};export function init(dom, theme, opts) { ... var existInstance = getInstanceByDom(dom); ... var chart = new ECharts(dom, theme, opts); chart.id = 'ec_' + idBase++; instances[chart.id] = chart; modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id); enableConnect(chart); return chart;} candlestick/preprocessor1234567891011121314import * as zrUtil from 'zrender/src/core/util';export default function (option) { if (!option || !zrUtil.isArray(option.series)) { return; } // Translate 'k' to 'candlestick'. zrUtil.each(option.series, function (seriesItem) { if (zrUtil.isObject(seriesItem) &amp;&amp; seriesItem.type === 'k') { seriesItem.type = 'candlestick'; } });} 仅仅是将series中的type === 'k'重新赋值了。 candlestick/candlestickVisualcandlestick/candlestickLayout","link":"/2020/06/08/about-the-implementation-of-the-echarts-candlestick/"},{"title":"go-kit_examples_shipping-analysis","text":"相关package prometheus 监控数据库 flag 解析命令参数","link":"/2018/10/24/go-kit-examples-shipping-analysis/"},{"title":"Parcel打包初体验","text":"Parcel号称极速零配置Web应用打包工具，相比于webpack的复杂性，Parcel确实为我们省去了很多配置。使用过facebook/create-react-app的同学应该会发现，creat-react-app也简化了配置，其包含react-scripts包，这个包做的事正与Parcel类似：将所有的打包配置统筹、封装。 Parcel基本用法安装Parcel全局安装Parcel:Yarn: 1yarn global add parcel-bundler npm: 1npm install -g parcel-bundler 创建、运行项目创建文件夹，并在文件夹下新建入口html和js文件，html引入入口js文件。 12345&lt;html&gt;&lt;body&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1console.log(\"hello world\") 在文件夹下初始化项目： 1yarn init -y 或 1npm init -y 启动服务开始开发： 1parcel index.html Parcel的基本用法介绍就此为止，就是这么简单，官网上有更详细的介绍。 项目迁移我们现在尝试将webpack配置的项目迁移到Parcel。 vue-cli webpack我们首先使用vue-cli创建一个项目: 1vue init webpack parcel-test 首先进入项目运行一下npm run dev，检查是否能运行成功，OK！运行成功。然后我们直接运行parcel index.htmlDANG!DANG! emmmmm... 好像没有将`main.js`引入html文件。改！ 修改引用路径。重启服务，出现错误 由于我们在`App.vue`中使用了`template`函数，而`import Vue from 'vue'`默认引用的运行时态版（不支持template函数），所以需要改用vue完整版。vue修改`main.js`和`router/index.js`文件中`vue`的引用 1import Vue from 'vue/dist/vue.esm.js' 再来运行一次`parcel index.html`便成功了，可以正常开发了。 小缺陷Parcel目前支持CommonJS 和 ES6 两种模块语法，所以，如果你在index.html页面引入了项目中非上述两种模块语法开发的js，那么可能会出现意外情况。如果还是想引入非CommonJS和ES6模块语法开发的js，目前可以有两种解决方法: 如果有源码，则改造代码 没有源码，并且还是压缩的，将其放在服务器上，html通过域名引用 将第三方的代码内联到html中 总结总体而言，Parcel确实比webpack要简化很多，几乎是开箱即用。对于没有特殊要求的项目，推荐使用。","link":"/2018/05/11/how-about-Parcel/"},{"title":"前端代码如何调试？","text":"前端代码的调试即javaScript调试，调试方法有很多，不同的开发者有不同的调试方式。这里介绍几种从入门到入坑的调试方法。 最简单调试方法：打印日志打印日志不仅仅是前端代码的调试方法，它几乎是大部分开发语言的入门级调试方法。很多开发者在新手阶段都会采用这一方式，将变量值等信息打印出来。javaScript输出日志主要方法是console对象。console对象有很多个方法，例如console.assert、console.clear、console.count等方法，其中与日志输出有关的方法有： 1234567console.log() // 打印字符串console.info() //打印一条信息console.error() // 打印一条错误信息console.warn() //打印一个警告信息 打印日志的调试方法超级简单，只需要在需要查看信息的代码行调用上面的方法即可输出想要的信息。上述4个方法均可将对象打印出来，例如： 12345var person = { name: 'Rose'}console.info('person', person) 如果使用的是Chrome浏览器，右键页面=&gt;检查，在console中即可看到相应的输出: 代码中插入debuggerjavascript提供了一个关键字：debugger，这个语句厉害了，可以调用任何可用的调试功能，设置断点。但是，如果没有调试功能可用，此语句将不起作用。下面是一个包debugger语句的html代码，当代码被执行时，会尝试调用一个可用的调试器进行调试。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;test&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var a = 1 a = a + 1 debugger a = a + 2&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 保存该文件，使用Chrome浏览器将其打开。打开Chrome developer tool， 即右键页面=&gt;检查，发现没啥呀，只有下面这个页面： 此时我们刷新页面，dang～dang～，变这样了： 看到图中标红的地方了吗？那就是我们设置的断点，程序运行到那里停止了。此时我们将鼠标移至变量`a`上，即可看到`a`的值。 下图中红圈内数字也可以设置断点。 编辑器中调试c++、Java、c#等语言都能在编辑器中进行调试、打断点，主要原因是它们都可以在编辑器中运行，而Web前端代码只能运行在浏览器中。 webstormwebstorm可以在编辑器中进行调试、打断点，十分方便。但是，webstorm运行时占用资源比较多，对于性能比较低的电脑，webstorm运行的不是很流畅。webstorm的调试方法可以在官网中找到。 Sublime TextSublime Text是一个比较轻量的脚本编辑器，运行比较流畅，很多前端开发者都喜欢使用。Sublime Text有几个可以实现调试的Package，但是试用了一下，没有成功 Visual Studio CodeVisual Studio Code具有Sublime Text轻量，同时也能实现调试，简直要抛弃Sublime Text投靠Visual Studio Code的怀抱了❤️ 1、安装Debugger for Chrome插件安装最新版的Visual Studio Code后，打开它，点击左侧扩展图标 在“在商店中搜索扩展”中输入“Debugger for Chrome”，安装Debugger for Chrome即可 安装成功后，先新建文件夹test/src，在其中新建index.html和index.js两个文件 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;o&lt;/div&gt; &lt;script src=\"./index.js\"&gt;&lt;/script&gt; &lt;script&gt; var result = add(1, 2) console.info('html', result) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js: 123456function add(a, b) { return a + b}var result = add(1, 2)console.info(result) 首先在index.js中打一个断点。点击图中红框区域即可添加断点，也可将鼠标放在红框区域右键添加、删除断点 选中test文件夹，按快捷键F5，或者点击调试-&gt;启动调试，选择Chrome。Visual Studio Code会自动在test文件夹下创建.vscode/launch.json文件。修改launch.json文件，修改或增加途中红线标识的行。 然后再次按F5或启动调试，此时Chrome会自动打开index.html，刷新页面，即可发现Visual Studio Code在刚才我们添加的断点出阻塞了 移动端网页调试移动端主要分Android和iOS，Windows Phone就暂时不考虑了，2017年销售的智能手机，99.9%的搭载了这两个操作系统。 Android端调试Android手机调试首先需要开启开发者模式，其次，如果是调试浏览器则需要安装Chrome浏览器，若是调试其他APP则需要APP开发者打开调试的开关。 完成上述步骤后，打开网页，使用usb线链接电脑，允许电脑调试手机。在PC端Chrome浏览器地址栏输入chrome://inspect iOS端调试网页macOS操作系统调试iOS网页比较简单，只需iPhone设置-&gt;Safari-&gt;高级-&gt;打开Web检查器开关，打开网页，iPhone通过数据线连接Mac电脑，打开Mac端Safari，点击开发-&gt;[你的手机]-&gt;选择调试的网页 也可以使用iPhone模拟器调试，前提需要安装Xcode。上图正是模拟器调试。 Windows操作系统要调试iOS端网页，则需要通过Chrome调试，并安装一些工具便可以调试Safari了 最强大的调试方法使用浏览器自带的调试工具，可以说是最常用，也是最强大的调试方法。不仅可以调试自己开发的网页，也可以hack其他网页，从别人那里学习一些前端知识。 Chrome浏览器的调试功能比较强大,其拥有很多功能，不仅可以查看、整理代码，还可以检查网页的性能、动画等等 Firefox浏览器调试功能也同样强大，完全媲美Chrome。最新版的Firefox在性能上有了很大的提升，渲染网页的速度赶超Chrome，资源占用却没有Chrome高。 国产浏览器中，如搜狗浏览器、UC浏览器等都支持调试，部分内核使用了Chromium，也就是Chrome内核，调试功能和Chrome差不多，可能有版本延迟，缺少部分新功能。","link":"/2018/05/06/how-to-debug-web-code/"},{"title":"JavaScript的内存管理，以及如何处理4种常见的内存泄漏","text":"起初从一个公众号中看到了这篇文章，拜读的时候发现有一两处地方有点难懂。于是尝试翻译一下原文，原文地址为How JavaScript works: memory management + how to handle 4 common memory leaks 作者针对JavaScript写了一系列的文章，第三篇便是此文章。第一篇和第二篇分别是How JavaScript works: an overview of the engine, the runtime, and the call stack、How JavaScript works: inside the V8 engine + 5 tips on how to write optimized code 文章开头讲叙了一些内存方面的基础知识，这里略过直接开车。 JavaScript的内存分配JavaScript对内存的分配进行自动管理，而不同于C语言需要开发者管理。 123456789101112131415var n = 374; // 为数字分配内存var s = 'sessionstack'; // 为字符分配内存var o = { a: 1, b: null}; // 为object和其属性分配内存var a = [1, null, 'str']; // 分配数组空间function f(a) { return a + 3;} // 为方法分配内存（方法本质上是一个可以回调的object）// 函数表达式也作为object来分配内存someElement.addEventListener('click', function() { someElement.style.backgroundColor = 'blue';}, false); 一些函数的返回结果也当作object分配内存： 123var d = new Date(); //分配一个Date objectvar e = document.createElement('div'); // 分配一个DOM 元素 一些方法也能分配新的值或object内存空间： 12345678var s1 = 'sessionstack';var s2 = s1.substr(0, 3); // s2 是一个新的字符变量// 由于已分配内存空间的字符,在内存空间中值是不变的// JavaScript可能不会给2分配新的内存空间,而是仅仅记录[0, 3]的区间.var a1 = ['str1', 'str2'];var a2 = ['str3', 'str4'];var a3 = a1.concat(a2);// 数组拼接将会分配新的内存空间 当内存不再需要时，内存空间会被释放大多数的内存管理问题都出现在这个阶段。在这个阶段，比较难的是如何判断内存空间可以释放掉了。这通常需要开发者确定哪些内存不再需要，然后将其释放。高等级的编程语言都会集成垃圾回收器。垃圾回收器对内存的分配和使用进行跟踪。当分配的内存不再需要时，垃圾回收器将会释放内存。 然而，总是有一些内存片段，垃圾回收器的算法难以判断其是否需要。大多数的垃圾回收器通过收集不再访问的内存，例如所有指向该内存的变量都已经不存在了。但是，可能存在一个变量一直指向某一内存空间，而程序不再使用该变量。 垃圾回收由于难以决定内存是否继续需要，垃圾回收器难以提供相应的解决方案。本节我们将会对垃圾回收器的回收算法一探究竟，并发现其存在的缺陷。 内存引用垃圾回收算法主要依赖于引用。 在内存管理这中，引用是一个对象可以访问(显式或隐式)另一个对象。例如，JavaScript对象继承了Object.prototype的属性和方法。其继承Object。prototype便是隐式引用，属性和方法便是显式继承。 垃圾回收算法：引用计数（reference-counting）rc垃圾回收是最简单的垃圾回收算法。如果指向对象的引用数量为0则这个对象是可以回收的。 看一下以下代码： 12345678910111213141516var o1 = { o2: { x: 1 }}// 创建了2个对象。其中，‘o2’被'o1'对象引用，作为'o1'的属性// 'o1'和'o2'都不能被回收var o3 = o1; //o3引用o1o1 = 1; // o1重新赋值，o1原来的内存现只被o3引用var o4 = o3.o2 // o4引用o2属性。现在o2属性在两处被引用o3 = '374' // 原o1的内存空间，被引用次数为0。但是其属性o2仍然被o4引用，不能被回收o4 = null // o2不再被o4引用，原o1引用数为0，现在可以被回收了 内存泄漏：循环引用下面的例子中，两个对象相互引用。方法调用完后，两个对象将不再需要，可以被释放。然而，rc垃圾回收算法认为每个对象都被引用了，所以不会回收。 123456function f() { var o1 = {} var o2 = {} o1.p = o2 // o1引用o2 o2.p = o1 // o2引用o1, 这就产生了循环引用} 垃圾回收算法：标记&amp;扫描（mark&amp;sweep）为了判断一个对象是否可以释放，m&amp;s算法是通过判断对象是否可达。 m&amp;s算法流程如下： 垃圾回收器首先建立了一个roots列表。roots通常是一些存在引用的全局变量，可以理解为引用的入口。在JavaScript中，“window”对象就是一个可以作为入口的全局对象 所有的root都被检查，并被标记为活动状态，也就是非垃圾。同时，所有root的所有孩子节点都也被递归检查。所有能从root可达的对象都不是垃圾。 剩余没有油被标记为活动状态的对象，都可以作为垃圾回收。垃圾回收器可以释放相应的内存，归还给系统。 m&amp;s算法要优于前面提到的引用计数算法，因为引用计数算法会导致一些对象从root不可达，而其又被引用了。m&amp;s算法可以释放部分存在循环引用的内存空间。 截止2012年，所有的浏览器都采取了m&amp;s垃圾回收机制。这里 详细介绍了垃圾机制，其中也包括m&amp;s垃圾回收机制及其优化。 循环引用不再是问题在上面的第一例子中，方法调用完后，方法中的两个对象不能从root可达，将被垃圾回收标记为不可达，进而被垃圾回收器回收。 垃圾回收机制的缺陷虽然垃圾回收器能够自动回收不再使用的内存空，但是，垃圾回收器执行回收的时机是不可预测的，也就是我们不知道垃圾回收什么时候会执行m&amp;s流程。有些情况下，即使里创建了一个数组，只要浏览器的可用内存足够，垃圾回收器可能就不会执行回收操作。 什么是内存泄漏内存泄漏可以定义为：应用程序不再需要的内存空间，由于某种原因，内存空间没有被系统回收，没有回到系统的可用内存池中。 编程语言通常有多种方法管理内存。但是，编程语言很难判断某一内存空间是否被使用。换句话说，只有开发者能明确的告诉浏览器某一内存空间是否能被系统回收。编程语言为开发提供了一些执行相应操作的功能，其他则需要开发者自身明确什么时候使用了内存。Wikipedia上有一些关于自动和人工管理内存的文章。 四种常见的内存泄漏1. 全局变量JavaScript处理没有申明的变量方式是将其作为浏览器的window的属性： 123function foo(arg) { bar = 'some text'} 等同于: 123function foo(arg) { window.bar = 'some text'} 浏览器测试效果： 所以，如果不小心忘记使用var或let等等申明bar变量，将会在方法内创建全局变量。使用ESlint进行代码规范是个不错的选择。 另一不小心创建全局变量的途径是通过this ： 12345function foo() { this.var1 = 'potential accidental global'}// 调用foo方法时，‘this’指向全局对象window，而不是undefinedfoo() 为避免这样的错误发生，建议在js文件第一行加入use strict。这能阻止意外产生全局变量。有关strict模式的更多内容，可以查看这里 严格模式。 在申明全局变量时建议赋值为null，在程序需要的地方再分配内存。 2. 遗漏计时器或者回调函数JavaScript的setInterval和setTimeout方法，如果不主动回收都可能导致内存泄漏。 关于回调函数导致的内存泄漏，原文提到了addEventListener和removeEventListener函数。然而，现代的浏览器都会在DOM被销毁时，其上绑定的事件也都会被回收，并不是严格要求addEventListener后，必须removeEventListener后才能回收内存。 3. 闭包JavaScript开发的一个重要特性就是闭包：内部的方法能够访问到外部（闭环）方法的变量。由于JavaScript运行时的具体实现，下面的代码可能导致内存泄漏： 123456789101112131415161718var theThing = nullvar replaceThing = function () { var originalThing = theThing var unused = function () { if (originalThing) // 引用originalThing console.log('hi') } theThing = { longStr: new Array(1000000).join('*'), someMethod: function () { console.log('message') } }}setInterval(replaceThine, 1000) 该代码执行内容是：每次replaceThing方法被调用，theThing都获取到一个包含大数组属性和闭包（函数）。同时，变量unused获得一个引用originalThing的闭包。是不是有点懵了？其实，只要记住一点：对子闭包而言，同一父闭包的内存空间是共享的。 在上面的例子中，unused是可以访问到someMethod的。在方法replaceThing方法外面，theThing可以调用someMethod。由于someMethod与unused共享闭包区域，unused对originalThing的引用，导致someMethod一直保持活动状态，阻止了其被回收，即使unused方法没有被回调。 仔细一想，原文的意思应该如下图所示： 随着定时器的执行，不断的有新的内存空间被分配，同时老的内存空间依然被引用，得不到释放。这个问题是Meteor团队发现的 4. DOM外引用有时候我们可能需要存储一些DOM的引用，以便多次访问。但是，当引用的DOM元素被从页面移除时，我们存储的DOM引用可能会导致内存泄漏。例如： 12345678910111213var elements = { button: document.getElementById('button'), image: document.getElementById('image')}function doStuff() { elements.image.src = 'http://example.com/image_name.png'}function removeImage() { document.body.removeChild(document.getElementById('image')) // 这时，我们依然在全局变量elements中引用了image，也就是，image元素仍然保存在内存中，不会被垃圾回收器回收} 所以，我们在创建引用的时候需要注意对DOM的引用。","link":"/2018/02/27/js-memory-manager-md/"},{"title":"mac下载编译chromium源码","text":"此文章来自网络。由于按照官方的教程没有成功编译iOS版，而按此文章成功编译，特此记录，原文链接 安装depot_tools工具获取depot_tools工具1git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 添加环境变量把depot_tools工具路径添加到系统的环境变量，~/.bashrc or ~/.zshrc。 1export PATH=$PATH:/path/to/depot_tools 获取chromium源码123mkdir chromiumcd chromiumfetch --no-history chromium --no-history参数可以不下载以往的历史信息。如果网络中断了，输入gclient sync继续下载。 获取依赖： 1gclient runhooks 更新代码： 12git rebase-updategclient sync 编译chromium源码 1234GYP_DEFINES=mac_sdk=10.11（可选）export GYP_GENERATORS=ninja,xcode-ninja./build/gyp_chromiumninja -C out/Release/ chrome 最新使用gn用于生成ninja文件，gn gen out/Default。 问题： 12345678910111213Traceback (most recent call last): File \"./gyp-mac-tool\", line 712, in &lt;module&gt; sys.exit(main(sys.argv[1:])) File \"./gyp-mac-tool\", line 29, in main exit_code = executor.Dispatch(args) File \"./gyp-mac-tool\", line 44, in Dispatch return getattr(self, method)(*args[1:]) File \"./gyp-mac-tool\", line 67, in ExecCopyBundleResource self._CopyStringsFile(source, dest) File \"./gyp-mac-tool\", line 133, in _CopyStringsFile import CoreFoundationImportError: No module named CoreFoundation[6208/20844] MACTOOL copy-bundle-resource ../../chrome/app/nibs/AppMenu.xib 解决： 1pip install pyobjc 运行chromiun编译完成后会在out/Release下生成Chromium.app，直接运行： 编译iOS平台为了编译成iOS平台的版本，可以直接把本地存在的Mac checkout转成iOS checkout，只要在chromium/.gclient文件的最后加一行target_os = [“ios”] 这里使用gn生成ninja文件(按照官方的教程，正是缺少此处)： 1gn args out/Debug-iphonesimulator 写入内容： 123456789# Set to true if you have a valid code signing key.ios_enable_code_signing = falsetarget_os = \"ios\"# Set to \"x86\", \"x64\", \"arm\", \"armv7\", \"arm64\". \"x86\" and \"x64\" will create a# build to run on the iOS simulator (and set use_ios_simulator = true), all# others are for an iOS device.target_cpu = \"x64\"# Release vs debug build.is_debug = true 最后执行： 1gclient sync 编译：这里有点不一样，可以先尝试： 1autoninja -C out/Debug-iphonesimulator gn_all or 1ninja -C out/Debug-iphonesimulator All 运行测试app（机型是iPhone 6,系统iOS 12.1）: 1out/Debug-iphonesimulator/iossim -d \"iPhone 6\" -s 12.1 out/Debug-iphonesimulator/Chromium.app 成功 单个模块1ninja -C out/Debug-iphonesimulator net 123export GYP_GENERATORS=xcode-ninja export CHROMIUM_GYP_FILE='net/net.gyp'./build/gyp_chromium 参考文档Get the Code: Checkout, Build, &amp; Run Chromium","link":"/2018/11/21/mac-build-chromium/"},{"title":"深入解析vue-cli 2.9.*实现原理","text":"vue-cli 3.0已出，你为什么还要看这个？ Vue-cli项目结构 其中，我们主要关注点在package.json\\bin\\lib这3个地方。 package.jsonpackage.json中主要关注bin: 12345\"bin\": { \"vue\": \"bin/vue\", \"vue-init\": \"bin/vue-init\", \"vue-list\": \"bin/vue-list\"} nodejs在解析命令时主要通过这个bin来运行相应的文件。&quot;vue&quot;:&quot;bin/vue&quot;nodejs会运行bin文件夹下的vue文件，同理，其他两个命令也一样。 bin/vue该文件内容比较少，其实整个脚本中代码量都比较少，因为模板内容都是从github上下载的。 12345678910111213#!/usr/bin/env nodeconst program = require('commander')program .version(require('../package').version) .usage('&lt;command&gt; [options]') .command('init', 'generate a new project from a template') .command('list', 'list available official templates') .command('build', 'prototype a new project') .command('create', '(for v3 warning only)')program.parse(process.argv) 这里列出了运行vue命令时的提示。如果在控制台运行vue init则会出现如下内容： 疑惑：这个是哪来的?bin/vue文件中并没有这些内容。正是这个疑惑导致了这个文章的出现。我们先来看一下package.json的bin下的vue-init命令，其运行的是bin/vue-init bin/vue-init我们来看一下该文件的一部分内容 1234567891011121314151617181920212223242526#!/usr/bin/env nodeconst program = require('commander')/** * Usage. */program .usage('&lt;template-name&gt; [project-name]') .option('-c, --clone', 'use git clone') .option('--offline', 'use cached template')/** * Help. */program.on('--help', () =&gt; { console.log(' Examples:') console.log() console.log(chalk.gray(' # create a new project with an official template')) console.log(' $ vue init webpack my-project') console.log() console.log(chalk.gray(' # create a new project straight from a github template')) console.log(' $ vue init username/repo my-project') console.log()}) 这一段正是vue init命令给出的提示。我们在控制台运行vue-init，也会出现同vue init一样的结果。难道vue init和vue-init两个命令相同？nodejs支持这样不同的命令运行相同的脚本？ “vue init” != “vue-init”，使他们运行同一个脚本的另有原因仔细分析，老司机就会发现其中共同的一点：const program = require('commander')。正是这个commander包实现了&quot;vue init&quot; == &quot;vue-init&quot;。 commandercommander是node.js 命令行接口的完整解决方案，灵感来自 Ruby 的 commander。其有Git风格的子命令，当使用.command()带有描述参数时，这告诉commander，你将采用当单独的可执行文件作为子命令。commander将会尝试在入口脚本的目录中搜索program-command形式的可执行文件，例如bin/vue文件中的.command('init', 'generate a new project from a template')，会使commander在bin文件夹下查找vue-init的可执行文件。 到这里，文章可以结束了。 vue-cli创建模板逻辑逻辑还是相对简单的，利用download-git-repo下载模板，download-git-repo默认从GitHub上下载。","link":"/2018/10/08/review-vue-cli-2-9/"},{"title":"从零开始，再造一个小程序平台","text":"微信发布小程序平台后，国内各大APP火速跟进，纷纷发布了自己的小程序平台。 速度真的很快，难道被微信形容“拥有出色体验”的小程序平台很容易实现？我们可以再造一个吗？ 起初，作者甚至不知道小程序是由Native实现，还是网页实现。既然要再造一个，那么首先要做的就是来了解小程序平台实现原理。 调研搜索没有参与过小程序平台的建设，所以只能发动搜索技能。所以这篇文章也更多的是管中窥豹，抛砖引玉。 搜索多篇与小程序实现原理有关的文章，认真拜读，发现在微信小程序平台发布之初，微信团队将小程序构建相关的脚本直接下发给了微信开发者工具，也就是小程序构建是在开发者端。现在新版的微信开发者工具中已经没有相关脚本了，推测是将构建转移到了服务器端。 从相关的文章中，我们了解猜想到了微信小程序实现方式：UI层由网页+原生渲染（部分组件是原生实现），Native运行逻辑层。 技术方案UI层渲染采用webview，js逻辑层呢？ React Native的js引擎主要采用了JavaScriptCore(苹果Safari浏览器js引擎)，Weex则是采用了Chrome V8引擎。 实现道理你都懂，那怎么实现呢？ UI和js逻辑在实现之前，我们首先来看看微信小程序的代码，分析一下。以一个小程序的index页面为例，其代码包含文件：index.js、index.json、index.wxml、index.wxss * index.js *index.js主要是业务逻辑代码，内容大致为： 1234567891011121314151617181920212223242526//index.js//获取应用实例const app = getApp()Page({ data: { motto: 'Hello World', userInfo: {}, hasUserInfo: false, canIUse: wx.canIUse('button.open-type.getUserInfo') }, //事件处理函数 bindViewTap: function() { wx.navigateTo({ url: '../logs/logs' }) }, onLoad: function () { if (app.globalData.userInfo) { this.setData({ userInfo: app.globalData.userInfo, hasUserInfo: true }) } }}) 小程序的页面逻辑代码均包含在Page({...})中。在js中，Page是一个函数。所以，小程序应该是调用了Native或者js的Page函数。 小编倾向于Page是调用了js函数。因为如果是Native函数，那么js中的this关键字将需要Native进行处理，js引擎可以处理的内容，没有必要交给Native来进行处理，或者是小编不知道Native有比较好的处理方式。 所以，我们需要处理的第一个内容是：使用js定义Page函数或者class，两者均可以实现。 * index.wxml *index.wxml是UI，是微信自定义xml标签，例如： 12345678910111213&lt;!--index.wxml--&gt;&lt;view class=\"container\"&gt; &lt;view class=\"userinfo\"&gt; &lt;button wx:if=\"{{!hasUserInfo &amp;&amp; canIUse}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\"&gt; 获取头像昵称 &lt;/button&gt; &lt;block wx:else&gt; &lt;image bindtap=\"bindViewTap\" class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" mode=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;{{userInfo.nickName}}&lt;/text&gt; &lt;/block&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;{{motto}}&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 自定义一整套的xml标签、属性会比较耗费时间，我们可以直接使用html标签。 * index.wxss *index.wxss主要是样式，和css基本一样，其内容我们完全可以直接引入网页中。微信小程序则是统一了rpx单位，想必是为了更好的兼容不同屏幕大小。 123456789101112131415161718192021/**index.wxss**/.userinfo { display: flex; flex-direction: column; align-items: center;}.userinfo-avatar { width: 128rpx; height: 128rpx; margin: 20rpx; border-radius: 50%;}.userinfo-nickname { color: #aaa;}.usermotto { margin-top: 200px;} * index.json *这个文件则是该页面的一些基本配置。我们主要关心一下usingComponents 123{ \"usingComponents\": {}} 这个应该就是小程序可以实现组件化开发的原因。usingComponents直接告诉了Native页面使用了哪些组件，方便Native获取组件模板和逻辑，然后进行渲染。 定义Page我们来使用js定义一个Page class，来作为每个页面的实例。当然也可以使用函数实现。 12345678910111213141516class Page { constructor(config) { this.data = config.data JSBridge.setData(config.data) // 小程序的onLoad生命周期函数 this.onLoad = config.onLoad // 这里与小程序有点不一样 // 模仿vue将非生命周期的函数都赋给methods属性 if (config.methods) { // 将所有method都指给class for (let key in config.methods) { this.key = config.methods[key] } } }} 另外我们需要注意的是小程序的setData函数。setData函数应该是调用Native，通知Native数据变更，重新渲染UI，所以我们还要在该class实现setData函数 12345678910111213141516171819202122// page.jsclass Page { constructor(config) { this.data = config.data JSBridge.setData(config.data) // 小程序的onLoad生命周期函数 this.onLoad = config.onLoad // 这里与小程序有点不一样 // 模仿vue将非生命周期的函数都赋给methods属性 if (config.methods) { // 将所有method都指给class for (let key in config.methods) { this.key = config.methods[key] } } } setData (data) { // JSBridge提供Native与js互相调用的api JSBridge.setData(data) }} 定义模板我们应该定义一个html模板，用来在webview中渲染UI。 1234567891011121314&lt;!-- templage.html --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;hybrid&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- app dom下渲染UI --&gt; &lt;div id=\"app\"&gt;{{template}}&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里涉及到一个比较重要的问题：UI的更新。考虑到性能，实现差量更新比较好。小编因此也再看了一遍Vue的虚拟DOM实现，其中涉及到差量更新。但是为了快速实现原型，我们直接进行全局更新。如何进行更新，这里采用native调用webview中js方法来实现。 123456789101112// templage.js// 可以inlinevar preTree = null/*** 渲染UI* @param {Object} domTree 树结构*/window.render = function (domTree) { if (!domTree) return // init UI document.querySelector('#app').innerHTML = domTree} 12// javathis.webView.loadUrl(\"javascript:render('\" + newTemplate + \"')\"); 至此，我们就可以作手来实现业务代码了。 业务代码实现模板index.xml和index.js逻辑，css暂不实现。* index.xml * 123&lt;div&gt; &lt;div onclick=\"onText\"&gt;{{text}}&lt;/div&gt;&lt;/div&gt; * index.js * 1234567891011121314151617var page = new Page({ data: { text: 'Hi, Java' }, onLoad: function () { this.setData({ text: 'I am Javascript' }) }, methods: { onText: function () { this.setData({ text: 'Hi, Javascript' }) } }}) Native端通过实现上文的UI和js逻辑我们需要Native端实现JSBridge api。我们首先要解决的是js引擎的使用。本文以Android为例，选取Chrome V8作为js引擎。 J2V8J2V8使用Java封装了对Chrome V8的操作，跨平台开发Tabris正是使用了J2V8来实现js构建原生应用。 我们可以通过官网https://eclipsesource.com/blogs/tutorials/getting-started-with-j2v8/了解如何使用J2V8。 Android引入使用Android Studio新建APP后，在build.gradle文件中添加J2V8依赖，选取aar版（已编译）或者使用J2V8源码自行编译： 123dependencies { implementation 'com.eclipsesource.j2v8:j2v8:4.8.2@aar'} 实现JSBridge定义一个Java类JSBridge，该类至少包含setData接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344package test.site.yiyan.j2v8;import android.util.Log;import android.webkit.WebView;import com.eclipsesource.v8.V8Object;public class JSBridge { String template; WebView webView; V8Object page; public void setPage (V8Object page) { this.page = page; } public void setWebView (WebView webView) { this.webView = webView; } public void setTemplate (String xml) { this.template = xml; } public String getTemplate () { return this.template; } public void setData (V8Object data) { // data业务逻辑状态 String[] keys = data.getKeys(); String newTemplate = this.template; // 遍历data中的状态 for (int i = 0; i &lt; keys.length; i++) { Log.i(\"setData\", keys[i] + ':' + data.get(keys[i])); // 将data状态写入UI newTemplate = newTemplate.replace(\"{{\" + keys[i] + \"}}\", data.get(keys[i]).toString()); } data.release(); if (keys.length &gt; 0) { // Native通过webview调用js，更新UI this.webView.loadUrl(\"javascript:render('\" + newTemplate + \"')\"); } }} Native初始化渲染Android中我们首先获取template.html内容，话不多说，看下面的Android代码注释。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162V8 jsRuntime;WebView mWebview;ProgressBar mProgressBar;V8Object mJSPageClass;JSBridge jsBridge;V8Object page;void loadHTMLTemplate () { String htmlTemplate = Utils.getAssetsScript(this, \"js/template.html\"); // 加载JSBridge initJSBridge(); mWebview.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { mProgressBar.setProgress(newProgress); if (newProgress == 100) { mProgressBar.setVisibility(View.GONE); // webview加载完成后 loadBussiness(); } super.onProgressChanged(view, newProgress); } }); mWebview.loadDataWithBaseURL(null, htmlTemplate, \"text/html\", \"utf-8\", null);}void initJSBridge () { jsBridge = new JSBridge(); V8Object jsBridgeObj = new V8Object(jsRuntime); jsRuntime.add(\"JSBridge\", jsBridgeObj); jsBridgeObj.registerJavaMethod(jsBridge, \"setData\", \"setData\", new Class&lt;?&gt;[] {V8Object.class}); jsBridgeObj.release();}void loadBussiness () { // Chrome V8 js引擎加载page.js String pageJS = Utils.getAssetsScript(this, \"js/page.js\"); mJSPageClass = jsRuntime.executeObjectScript(pageJS); // 获取业务模板 String indexXML = Utils.getAssetsScript(this, \"demo/index/index.xml\"); jsBridge.setWebView(this.mWebview); jsBridge.setTemplate(indexXML); Log.i(\"J2V8\", \"indexXML:\" + indexXML); // 加载业务js String indexJS = Utils.getAssetsScript(this, \"demo/index/index.js\"); jsRuntime.executeScript(indexJS); page = jsRuntime.getObject(\"page\"); Log.i(\"J2V8\", page.toString()); // 获取page的data属性 V8Object pageData = page.getObject(\"data\"); // 渲染初始UI mWebview.loadUrl(\"javascript:render('\" + indexXML + \"')\"); // Native调用V8中js函数，执行生命周期：onLoad page.executeFunction(\"onLoad\", null); pageData.release();} 总结这是啥啊？这不是再造一个浏览器吗？！ 不不，浏览器远比这复杂，并且js不能直接操作dom（也可以定义接口来实现），还有很多内容需要完善，例如实现js的window函数：setTimeout等。 至于性能方面，是不是比直接使用webview的性能要好，这还要进一步完善丰富原型和DEMO。 其实在官方的文档中已经阐述了实现原理：","link":"/2019/02/23/recreatomg-a-small-program-framework/"},{"title":"rollup:打包小而美的公用插件","text":"Rollup是一个Javascript模块打包器，可以将组件打包成独立的模块。","link":"/2020/09/02/rollup/"},{"title":"top-frameworks-trends-2018","text":"来自85个国家的超过1,000名参与者和大量数据，JAXenter调查了2018年哪些技术主题值得关注，并与历史进行了对比。 Web框架React、Angular和Node.js排名占据前3，我们可以看出JavaScript开发框架可以说是最近几年最受欢迎的web框架。排在第四位的是Java生态系统的Spring MVC，紧接其后的是国内大受欢迎的Vue.js。 我们来回顾一下2016年和2017年，web框架的排名。 Angular在2016年的时候可能不叫受欢迎，但是后来被React后来居上。React在今年将会继续超越Angular。Java生态的web框架越来越不受欢迎了，例如Spring MVC. 应用程序框架Java生态中Spring Boot越来越受欢迎。不知道新秀Eclipse MicroProfile未来表现如何。 对比2016年和2017年的发展趋势： UI toolkits2018年，HTML5将是绝对的王者，紧随其后的是Bootstrap和Web组件。 来看一下Java UI toolkits在2016年和2017年的情况。 程序员们对JavaFX的兴趣似乎有所减少，但是它仍然排在Swing和SWT前。需要注意的是，从JDK11开始，JavaFX将作为与JDK分离，作为独立的模块。Oracle在一份白皮书中写道，截至2022年3月，JavaFX新修补程序将继续得到Java SE 8的支持，并宣布他们“正在与感兴趣的第三方合作，以便更容易地构建和维护JavaFX作为单独分发的开源模块“。 我们来对比一下UI Frameworks在2016年和2017年的表现： JavaScriptJavaScript框架显然是这次的精华，让我们仔细看看过去三年情况如何变化。 React、Angular和Node.js遥遥领先，HTML5和Bootstrap的阵地也很大。 Web Components是一套不同的技术（不是React中所涉及到的组件），允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的web应用中使用它们，有点类似React，但是区别也挺大，很容易被人忽视，因为React、Vue中也有组件的概念，不知道其发展将如何。","link":"/2018/05/17/top-frameworks-trends-2018/"},{"title":"Go语言的5大开源库","text":"Go语言可以说是一个开箱即用的编程语言，其性能出众、支持分布式等特性深得程序员的喜爱。小编之前在毫无Go语言开发经验的情况下，只花了一个星期便掌握了Go语言的基本特性，后来也没花几天便搭建了一个数据库为mongoDB的服务器，并实现了相当复（chong）杂（fu）的功能，可见其上手非常简单。 下面介绍5个在GitHub上比较火热的Go语言开源工具库。 Go kit：微服务工具包Go kit微服务工具包为微服务提供了一系列的功能，使搭建微服务特别方便，开发人员只需要关注业务逻辑即可。限于篇幅，这里列出Go kit提供的几项功能： jwt(JSON web token):一种认证通信双方的协议 RPC（远程过程调用）基础支持 grpc：Google开源RPC框架 http服务 LB负载均衡 ZK（ZooKeeper）支持：分布式服务框架 Graphite:支持监控系统 InfluxDB: 时间序列数据库 GORMORM是什么？对象关系映射（Object Relational Mapping）,是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。通俗一点讲：操作数据库。GORM具有很多功能，具其官网介绍，具备一下功能： 全功能ORM（无限接近） 关联（包含一个，包含多个，属于，多对多，多态） 钩子 (在创建/保存/更新/删除/查找之前或之后) 预加载 事务 复合主键 SQL 生成器 数据库自动迁移 自定义日志 可扩展性, 可基于 GORM 回调编写插件 所有功能都被测试覆盖 开发者友好 clicli，可以用来快速的创建go语言命令行工具，目前在GitHub上的star数为8k+。 vegetavegetahttp负载测试工具。 fuzzyfuzzy,go语言实现的字符串模糊匹配工具。 build-web-application-with-golang除了上面提到的几个工具外，在GitHub上还有一个比较火热的项目，star数量达到了2万多。其实，称之为项目并不准确，应该说是博客，它从零开始，详细的介绍了如何一步步搭建Go语言开发环境、搭建web服务器、连接数据、部署等等，几乎一整套的Go语言建站方法，它就是:build-web-application-with-golang。它不仅有中文版，还有英文、法文、日文版等等多种语言。从介绍页面上，其包含浓浓热情、求赞助的支付二维码来看，这是国内开发者贡献的，点赞！","link":"/2018/05/13/top5-libraries-for-Go/"},{"title":"抛弃contenteditable，实现富文本编辑器","text":"有时候使用contenteditable=true来实现编辑器并不能满足需求 移动端使用contenteditable=true的一些不成问题的问题使用contenteditable=true实现编辑器，经过不断的优化，是可以解决很多问题的。下面一一列出一些问题及其解决方法。 问题一：插入超链接和图片如果不是复制粘贴的方式插入，而是采用点击工具栏，编辑超链接或者是调用相册的方式插入，则中间会出现焦点丢失，那么如何实现插入的图片在焦点的位置？解决方法是： 1、在点击用户工具栏时，记录焦点位置。截获用户点击最好采用touchstart事件，避免记录的焦点位置不是编辑区内。 12var selection = getSelection()this.globalRange = selection.getRangeAt(0) 2、在获取到图片资源后，利用this.globalRange插入图片节点 123// 创建图片节点var imgNode = this.createImgNode(src)this.globalRange.insertNode(imgNode) 问题二：光标位置有些情况下，你可能需要知道光标的位置，top、left是多少。可以使用getSelection().focusNode()获取到聚焦的节点，有时得到的节点是text类型（没有top、left属性），可以通过通过其父节点大致得到位置。所以，只是得不到准确的位置。 为什么要得到光标位置？iOS端键盘弹出后，position:fixed的效果发生了变化，难以固定dom。所以，如果存在工具栏，可以将工具栏跟随光标，提升一点点体验。 问题三：删除图片需求的设计稿是要求图片左上角有一个X按钮，来删除图片。 如果不对这个这个删除按钮添加属性，那么用户可以编辑这个按钮，虽然影响不大，导致这个删除按钮的意义荡然无存。讲道理，这个删除按钮应该不能编辑，所以，在删除按钮和图片上加上属性contenteditable=&quot;false&quot;。但是，这又会导致其他问题：插入图片后，我的光标聚焦到哪里？按钮删除图片也可能导致一些难以预料的问题。 加不加contenteditable=&quot;false&quot;是矛盾的。也正是这样一个矛盾的存在，导致了我们不使用contenteditable=&quot;true&quot;来实现编辑器，可以说是一个X引发的大型搬砖事件富文本重构。 自实现富文本编辑器需要确定的数据结构我们需要获取用户输入，所以可以用隐藏的textare或者input等来获取输入。首先需要确定的是数据结构（内容和光标），以便实现自动换行、行内富文本，渲染内容 数据结构：内容网页文本有自动换行的特性，在移动端则更为明显，因为屏幕更小。另外，行内还要支持行内图片、超链接等数据。所以，基本可以确定是，行内要包括多种类型的数据。 1234567891011121314151617// line{ \"inlines\": [ { \"type\": \"text\", \"value\": \"\" }, { \"type\": \"href\", \"value\": \"超链接\" }, { \"type\": \"img\", \"value\": \"图片src\" } ]} 如果一个div内文本或图片等内容足够多，那么会被自动换行，此时，如果用户聚焦到该div进行编辑，我们其实很难计算用户点击了哪里，很难计算行末尾的位置，也难以计算光标位置。 如果将一个div内的内容看成很多行的合集，那么我们能知道每一行的宽度，是否占满了一行。 根据自动换行，如果没占满一行，则要向下一行借，补足一行。而两个div之间，则不存在前一行向下一行借的情况。所以，我们可以将div视为一个段落，段落每行自动占满一行。那么每一段又分为很多行。段分为两种类型：图文混排的rich和独占一段的block 12345678910111213141516171819202122// 段{ \"type\": \"rich\", \"lines\": [ { // line \"inlines\": [ { \"type\": \"text\", \"value\": \"\" }, { \"type\": \"href\", \"value\": \"超链接\" }, { \"type\": \"img\", \"value\": \"图片src\" } ] } ]} 所以，富文本是很多段的组成，和word文档一样。 12345[ { // 段 \"lines\": [] }] 将数据结构渲染出来，大致的DOM结果为： 1234567&lt;div class=\"paragraph\"&gt; &lt;div class=\"line\"&gt; &lt;span class=\"inline_text\"&gt;文本&lt;/span&gt;&lt;img class=\"inline_img\" /&gt; &lt;/div&gt; &lt;div class=\"line\"&gt;...&lt;/div&gt;&lt;/div&gt;&lt;div class=\"paragraph\"&gt;&lt;/div&gt; 直观的效果便是： 数据结构：光标定义好数据结构，意味着如何计算光标位置也有了方向。光标的位置采用postion: absolute;来定位，所以富文本编辑器DOM应该是postion: releative;如果存在以下一段内容。 123456789101112131415[ // 段 { \"lines\": [ { // line 第一行 \"inlines\": [ { \"type\": \"text\", \"value\": \"富文本编辑器\" } ] } ] }] 那么，我们想定位到第一行行末，那么光标的left值则是富文本编辑器的宽度，也就是&lt;span&gt;富文本编辑器&lt;/span&gt;宽度，光标的高度也可以得到。而top值则只需要在渲染出来的DOM中，找到第一段第一行的offsetTop。所以，如果是要将光标定位到富文本后，则top值不变，left值为富文本的宽度。 我们要总结一下光标所具有的属性：段、行，以及行内位置，行内位置则需要记录所在行内文本的字符在第几个字符后面。所以基本属性为 123456789101112cursor = { top: 0, left: 0, // 所在段下标 paragraphIndex: 0, // 行下标 lineIndex: 0, // 行内下标 inlineIndex: 0, // 字符位置 charAt: 0} 这帮助我们确认了光标的位置，在内容中的位置，以便进行内容的增、删操作。 突然想到我们可以看看vscode的源码，看它是如何利用electron来实现换行、光标定位。我们虽然分析过ace.js，但是其对代码是不自动换行的，虽然vscode也是如此，但是对markdown却是自动换行的。 层次结构我们需要将编辑的内容、光标、隐藏的textarea等渲染出来。另外还需要计算字符宽度来计算光标位置。所以，我们需要将编辑区域分为以下几层： 1234&lt;div class=\"content\"&gt;渲染内容层&lt;/div&gt;&lt;div class=\"cursor\"&gt;光标层&lt;/div&gt;&lt;textarea&gt;隐藏的输入层&lt;/textarea&gt;&lt;div class=\"measure\"&gt;计算层&lt;/div&gt; 渲染内容层：如名 光标层：显示光标 隐藏的输入层：获取用户输入 计算层：计算字符宽度，行高等。 逻辑逻辑涉及到：渲染、输入、点击 渲染内容渲染内容上文有提到，只要每一行的内容不超过一行的行宽，渲染出来的结构基本如上。而保证每一行的行高，则需要计算每一行的内容，在后面获取用户输入会提到。 注意要将空格转换为&nbsp;，避免页面渲染空格失败。 获取用户输入获取用户输入，需要监听两种事件：input、keydown，处理四种基本状态：insertText、compositionend、Backspace、Enter 事件：inputinput需要监听的基本事件：insertText、compositionend。两者都是插入字符，compositionend则是连续输入的结束状态，例如拼音输入。 在光标位置插入字符，并将聚焦的inline右侧的inlines和后续行均进行后移，也就是重新分行，这是整个编辑器的核心，删除、换行、插入都是基于此流程来实现。具体流程为： 事件：keydown键盘按键事件，移动端最基本的是需要处理两种key：Backspce、Enter Backspace:删除删除需要将cursor前的字符或者内容删除，同时将聚焦的inline右侧的inlines和后续行均进行缩进 删除字符需要注意的是：字符长度不一定为1，一些表意文字，例如输入法的表情😄，其字符长度是2。所以需要用正则匹配光标前的字符。 Enter:换行换行是将光标后的内容插入到新段中。 点击鼠标的点击分为两种：聚焦和删除（点击了删除图标） 聚焦在渲染内容时将paragraph、line、inline的信息都记录到dom中 1234567&lt;div class=\"paragraph\" data-paragraph=\"0\"&gt; &lt;div class=\"line\" data-paragraph=\"0\" data-line=\"0\"&gt; &lt;span class=\"inline_text\" data-paragraph=\"0\" data-line=\"0\" data-inline=\"0\"&gt;文本&lt;/span&gt;&lt;img class=\"inline_img\" data-paragraph=\"0\" data-line=\"0\" data-inline=\"1\"/&gt; &lt;/div&gt; &lt;div class=\"line\" data-paragraph=\"0\" data-line=\"1\"&gt;...&lt;/div&gt;&lt;/div&gt;&lt;div class=\"paragraph\" data-paragraph=\"1\"&gt;&lt;/div&gt; 通过点击的target，获取聚焦的inline，通过点击的offsetY确定光标top位置，offsetX（相对target的偏移）计算出光标left位置。left计算方法，则是依次将inline左侧的字符取出，得到字符宽度与offsetX进行比较。 删除鼠标点击的删除，主要是针对段type=”block”。删除则是删除整段，更新DOM。 总结比较简单的富文本还是建议使用contenteditable=true来实现。如果在移动端，则建议不要采用富文本的思想，而是文本与图片分离的数据结构。","link":"/2020/04/03/html-editor/"},{"title":"vue-loader如何配置cssModules","text":"在使用vue cli 2系列进行模块编程时，为避免css冲突，我们常采用vue-loader的scoped和module方法来实现。 scopedscoped使用方法最为简单，只需要在.vue文件的&lt;style&gt;标签增加scoped属性即可。 123456789&lt;template&gt; &lt;div class=\"example\"&gt;hi&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.example { color: red;}&lt;/style&gt; scoped:注意⚠️但是会有一个问题：子组件的跟节点会收到父组件的影响，这也是scoped本身的特性决定的。例如：我们在子组件的根结点设置wrap class，在父组件中也设置wrap class。 child.vue123456789&lt;template&gt; &lt;div class=\"wrap\"&gt;test&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.wrap{ margin-top: 10px}&lt;/style&gt; parent.vue1234567891011121314151617181920&lt;template&gt; &lt;div class=\"wrap\"&gt; &lt;child /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './child'export { components: { Child }}&lt;/script&gt;&lt;style scoped&gt;.wrap{ padding-top: 20px}&lt;/style&gt; 效果为： 解决方法： 改子组件或父组件的class名：改名字是不阔能的，这辈子都不阔能的。如果要改，我们要模块化css有何用？ 子组件外再包裹一个无class的元素：确实能解决，但是这种方法我是拒绝的，因为会增加dom CSS Modules说到上面的问题，CSS Modules就可以解决：CSS Modules会给每个clsss生成一个唯一的class名，其依据了文件路径等信息，采用hash加随机数得出唯一的class名。在.vue文件中使用方式如下： 123456789&lt;template&gt; &lt;div :class=\"$style.wrap\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;style module&gt;.wrap{ margin: auto;}&lt;/style&gt; 但是我会小改一下，因为懒得每次写$style 123456789&lt;template&gt; &lt;div :class=\"s.wrap\"&gt;&lt;/div&gt;&lt;/template&gt;&lt;style module=\"s\"&gt;.wrap{ margin: auto;}&lt;/style&gt; 本文中心思想：表达了作者…在vue-cli 2系列中使用CSS Modules时，如果仅仅采用上述方式，会发现很难进行调试了：完全不知道网页渲染出的class对应源码中的哪一个。 所以需要在vue-load.conf.js文件中进行配置，来告诉vue-loader如何生成class名。作者通常采用以下配置来命名： 1234cssModules: { localIdentName: '[local]-[hash:base64:5]', // 指定命名采用：局部名-5位的hash camelCase: true} 指定命名完整参考为 1localIdentName: '[path][name]---[local]---[hash:base64:5]' 命名具体可以参考postcss-modules，以及vue-loader v14","link":"/2018/10/31/vue-loader%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEcssModules/"},{"title":"v8:c++高性能垃圾回收","text":"文章翻译自Chromium v8引擎官方文章：High-performance garbage collection for C++（2020年5月26日） Chromium V8引擎、Flutter的skia等宣称高性能、声望高的框架均使用了C++编写，难道移动端C++的春天来了？ 之前有三篇文章介绍了V8引擎是如何实现和优化：JavaScript垃圾回收和DOM模型：Tracing from JS to the DOM and back again、Trash talk: the Orinoco garbage collector、Concurrent marking in V8。不过，并非Chromium中所有的东西都是JavaScript，因为大多数的浏览器和嵌入V8引擎的Blink渲染引擎都是用C++写的。JavaScript可以用于与DOM交互，再由渲染管道处理DOM。 因为围绕着DOM的C++对象图（object graph）与JavaScript对象严重的纠缠在一起，Chromium团队在几年前将垃圾回收器更换为了：Oilpan ,专治这种内存。Oilpan垃圾回收器使用C++编写，为管理内存，Oilpan与V8相连，通过cross-component tracing技术将纠缠在一起的C++/JavaScript对象图视为一个堆。 本文是一系列Oilpan博客文章中的第一篇，该系列文章将提供对Oilpan及其c++ api的核心原则的概述。在这篇文章中，我们将介绍一些受支持的特性，解释它们如何与垃圾收集器的各个子系统交互，并深入研究清理器中的并发回收对象。 令人兴奋的是，Oilpan目前是在Blink中实现的，但正在以垃圾收集库的形式转移到V8中。我们的目标是让所有的V8嵌入程序和更多的c++开发人员都可以轻松地使用c++垃圾收集。 背景Oilpan实现了一个标记-删除的垃圾回收器，它的回收过程分为两部分： 标记: 对托管的堆进行活动对象扫描； 删除: 回收托管堆上的死对象。 我们已经在Concurrent marking in V8中介绍了标记的基本知识。简单来说：扫描所有object来寻找活动的object，这个过程可以看作图形遍历，object是节点，指针是边。遍历是从根节点开始，根节点指registers、本地执行栈，以及其他的全局对象。 在上述方面，C++与JavaScript相同。与JavaScript相反，C++的对象都是静态类型，所以不能在运行时改变它们的表示。使用Oilpan管理的c++对象利用了这一事实，并通过访问者模式提供了指向其他对象(图中的边)的指针的描述。描述Oilpan对象的基本模式如下： 12345678910111213141516class LinkedNode final : public GarbageCollected&lt;LinkedNode&gt; { public: LinkedNode(LinkedNode* next, int value) : next_(next), value_(value) {} void Trace(Visitor* visitor) const { visitor-&gt;Trace(next_); } private: Member&lt;LinkedNode&gt; next_; int value_;};LinkedNode* CreateNodes() { LinkedNode* first_node = MakeGarbageCollected&lt;LinkedNode&gt;(nullptr, 1); LinkedNode* second_node = MakeGarbageCollected&lt;LinkedNode&gt;(first_node, 2); return second_node;} 上例中，LinkedNode由Oilpan管理，它继承自GarbageCollected&lt;LinkedNode&gt;。LinkedNode构造函数初始化了next_, value_两个属性。当垃圾回收器处理一个Object时，它通过调用LinkedNode的Trace方法来发现出发的指针。Member是由Oilpan提供的智能指针，语法上与std::shared_ptr相似，用于在遍历图形树时保持一致状态。这使得Oilpan能够精确的知道指针在其管理对象中的位置。 热心的读者可能注意到了，在上面的示例中，堆栈上的第一个节点和第二个节点被作为原始c++指针保存。Oilpan不会给工作的堆栈添加，在处理根目录时，只依赖保守的堆栈扫描来查找到其托管堆的指针。它的工作原理是逐词迭代堆栈，并将这些词解释为指向托管堆的指针。这意味着在访问堆栈分配的对象时，Oilpan不会造成性能损失。相反，它将成本转移到垃圾收集时间，在垃圾收集时间中，它谨慎地扫描堆栈。集成在渲染器中的Oilpan试图延迟垃圾收集，直到垃圾收集达到保证没有感兴趣的堆栈的状态。由于web是基于事件的，并且执行是由事件循环中的处理任务驱动的，这样的机会非常多。 Oilpan被用在Blink中，Blink是一个大型的c++代码库，有很多成熟的代码，它也支持： 通过混合和对混合的引用(内部指针)进行多重继承 在执行构造函数期间触发垃圾收集 通过被视为根的Persistent智能指针使对象在非托管内存中保持活动状态 集合包含序列(如向量)和关联(如集合和映射)容器，并具有集合备份的压缩。 弱引用、弱回调和ephemerons 在收回单个对象之前执行的终结器回调。 扫描C++请继续关注另一篇博客文章，它将详细介绍Oilpan做标记是如何工作的。本文中，我们假设已经完成了标记，并且通过Trace方法，Oilpan已经发现了所有可到达的对象。标记完所有可达Object后，它们都会有标记位。 清理现在是回收死对象(标记期间不可访问的)的阶段，它们的底层内存要么返回到操作系统，要么供后续分配使用。下面，我们将从使用和限制的角度展示Oilpan的清扫器是如何工作的，以及它是如何实现高回收吞吐量的。 清理器通过迭代堆内存并检查标记位来找到死对象。为了保持c++语义，清理器必须在释放内存之前调用每个死对象的析构函数。非平凡析构函数是作为终结器实现的。 从程序员的角度来看，析构函数的执行没有定义顺序，因为清理器使用的迭代不考虑构造顺序。这强加了一个限制，即终结器不允许接触堆上的其他对象。这对于编写用户代码来说是一个常见的挑战，因为托管语言通常在它们的结束语义中不支持顺序(例如Java)。Oilpan使用一个Clang插件，该插件静态地验证在对象销毁期间没有访问堆对象： 12345678910111213class GCed : public GarbageCollected&lt;GCed&gt; { public: void DoSomething(); void Trace(Visitor* visitor) { visitor-&gt;Trace(other_); } ~GCed() { other_-&gt;DoSomething(); // error: Finalizer '~GCed' accesses // potentially finalized field 'other_'. } private: Member&lt;GCed&gt; other_;}; 对于需要在对象销毁之前访问堆的复杂用例，Oilpan提供了预终结回调。在每个垃圾收集周期中，这些回调函数比析构函数施加了更多的开销，并且只在Blink中少量使用。 增量和并发清理现在我们已经讨论了托管c++环境中的析构函数的限制，是时候看看Oilpan如何实现和优化清扫阶段了。 在深入讨论细节之前，有必要回顾一下程序通常是如何在web上执行的。任何执行任务，如JavaScript程序和垃圾回收器，都是在诛仙城中执行，通过在事件循环中分配任务触发。渲染器与其他应用程序环境非常相似，它支持在主线程并发运行的后台任务，以帮助处理任何主线程工作。 简单来说，Oilpan垃圾回收器运行在主进程上，运行时会使应用程序暂停执行： 暂停进程的扫描 对于具有软实时约束的应用程序，处理垃圾收集时的决定因素是延迟。“停止世界”清理可能会导致大量的暂停时间，从而导致用户可见的应用程序延迟。为减少延迟，下一步采用增量清理： 增量清理 使用增量方法，清理被分解并委托给其他主线程任务。在最好的情况下，这些任务完全在空闲时间执行，避免干扰任何常规的应用程序执行。在内部，清扫器根据页面的概念将工作划分为更小的单元。页面可能处于两种有趣的状态：to-be-swept页面仍然需要被清理，already-swept页面已经被清理。分配只考虑已经清理过的页面，并将从空闲列表中重新填充本地分配缓冲区(LABs)，空闲列表维护可用内存块的列表。为了从空闲列表中获取内存，应用程序首先尝试在已清理的页面中查找内存，然后通过将清理算法内联到分配中来帮助处理要清理的页面，并且只在没有内存的情况下向OS请求新的内存。 Oilpan使用增量清理已经很多年了，但是随着应用程序及其生成的对象图越来越大，清理开始影响应用程序的性能。为了改进增量清理，我们开始利用后台任务并发回收内存。有两个基本的不变量用于排除执行清扫器的后台任务和分配新对象的应用程序之间的任何数据竞争： 清理器只处理死内存，应用程序无法访问的死内存； 应用程序只分配已经清理过的页面，这些页面已被清理器标记为不再处理。 这两个不变量都确保不存在对象及其内存的竞争者。不幸的是，c++严重依赖析构函数，而析构函数是作为终结器实现的。Oilpan强制终结器在主线程上运行，以帮助开发人员并排除应用程序代码本身中的数据竞争。为了解决这个问题，Oilpan将对象的终结延迟到主线程。更具体地说，每当并发清理程序遇到一个具有终结器(析构器)的对象时，它就会将其推到一个终结队列上，该队列将在单独的终结阶段中处理，该阶段总是在运行应用程序的主线程上执行。并发清理的整个工作流如下所示： 使用后台任务的并发清理 由于终结器可能需要访问对象的所有有效负载，因此将相应的内存添加到空闲列表中会延迟到执行终结器之后。如果没有执行终结器，在后台线程上运行的清理器会立即将回收的内存添加到空闲列表中。 效果后台清理已经在Chrome M78中发布。我们实际的基准测试框架显示，清理主线程的时间减少了25%-50%(平均为42%)。请参见下面所选的行项目集。 主线程扫描时间(毫秒) 花费在主线程上的其余时间用于执行终结器。正在进行的工作是减少Blink中大量实例化的对象类型的终结器。这里令人兴奋的是，所有这些优化都是在应用程序代码中完成的，因为在没有终结器的情况下，清理将自动进行调整。 请继续关注更多关于c++垃圾收集的文章，以及关于Oilpan库更新的文章，因为我们即将发布一个可供所有V8用户使用的版本。","link":"/2020/07/15/v8-high-performance-grabage-collection-cpp/"},{"title":"webpack devServer代理解决跨域失败的情况：get请求无origin，而post请求有","text":"前后后端分离开发，普遍会存在跨域的问题。前端在使用webpack开发时，通常采用代理的方式来解决跨域问题。 通常在webpack的devServer进行如下配置 123456789devServer: { ... proxy: { '/api': { target: \"http://target.api.domain.com\", changeOrigin: true, } },} 如此配置基本可以解决大部分的跨域问题。 但是，在后台将允许的跨域地址指定为一个后，上述配置便对post请求不生效了，也就是post请求跨域失败，而get请求成功。 对比get和post请求的不同，发现get的请求头里面没有origin字段，而post请求里面有origin字段。为什么get请求头部没有origin字段，而post请求头部有origin字段 在命令行中使用curl工具请求接口，header中不设置origin字段请求成功，一旦设置为本机开发服务IP地址和端口，post请求就失败。 在webpack的devServer采用http-proxy-middleware来代理转发请求，配置中changeOrigin的作用是： changes the origin of the host header to the target URL。 changeOrigin: true为什么没有生效？没有进行抓包分析。 http-proxy-middleware的配置中还有一个headers的配置，将上述配置修改为： 12345678910111213devServer: { ... proxy: { '/api': { target: \"http://target.api.domain.com\", changeOrigin: true, headers: { host: \"http://target.api.domain.com\", origin: \"http://target.api.domain.com\" } } },} 成功 那么问题来了：为什么get请求头部没有origin字段，而post请求头部有origin字段？","link":"/2019/02/13/webpack-proxy/"},{"title":"webpack4配置vue-style-loader出现css没有加载的异常","text":"在使用webpack4配置vue脚手架时，按官方的教程，使用webpack-dev-server运行，出现了单文件组件的css没有生效的问题。 vue-loader官方给出的配置是： 12345678910111213141516171819202122232425262728293031323334// vue-loader官方教程// webpack.config.jsconst VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = { mode: 'development', module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader' }, // 它会应用到普通的 `.js` 文件 // 以及 `.vue` 文件中的 `&lt;script&gt;` 块 { test: /\\.js$/, loader: 'babel-loader' }, // 它会应用到普通的 `.css` 文件 // 以及 `.vue` 文件中的 `&lt;style&gt;` 块 { test: /\\.css$/, use: [ 'vue-style-loader', 'css-loader' ] } ] }, plugins: [ // 请确保引入这个插件来施展魔法 new VueLoaderPlugin() ]} 后将处理css的loader改为style-laoder后正常： 1234567{ test: /\\.css$/, use: [ 'style-loader', 'css-loader' ]} 查询vue-style-loadergithub上issue发现是css-loader 4.x与vue-style-loader 4.x不匹配： 意思是： 如果想使用css-loader 4.x则不能使用vue-style-loader，要用style-loader; 如果想使用vue-style-loader,则要将css-loader改为3.6.0版本； vue-cli-service@4.4.6使用了css-loader@3.6.0","link":"/2020/08/13/webpack4-vue-style-loader/"},{"title":"WEEX开发实现native端hotreload","text":"相关版本：weex-toolkit: 1.2.9playground: 0.5.2.5 在进行weex开发，修改代码时，网页能进行自动刷新，方便开发人员看到改动。但是，在app端，由于加载的仅仅是业务代码的js文件，不能实现自动刷新。 在官方提供的playground app中，在界面上添加了刷新按钮，来手动刷新。but…有点懒，想想其他办法。 在playground的代码中发现了hotreoload的相关代码：WXPageActivity.java 1234567891011121314151617181920212223242526272829 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_wxpage); setCurrentWxPageActivity(this); ... if(WXPAGE.equals(mUri.getScheme())|| ... startHotRefresh(); ... }else if (TextUtils.equals(\"http\", mUri.getScheme()) || TextUtils.equals(\"https\", mUri.getScheme())) { ... startHotRefresh(); } ... }/** * hot refresh */ private void startHotRefresh() { try { String host = new URL(mUri.toString()).getHost(); String wsUrl = \"ws://\" + host + \":8082\"; mWXHandler.obtainMessage(Constants.HOT_REFRESH_CONNECT, 0, 0, wsUrl).sendToTarget(); } catch (MalformedURLException e) { e.printStackTrace(); } } 虽然有hot refresh的代码，但是没用。因为startHotRefresh()中监听的是String wsUrl = &quot;ws://&quot; + host + &quot;:8082&quot;; 8082端口，而我们的weex-toolkit创建的项目没有创建相应的socket server。 估计官方填坑只填了一半。怎么肥四！？ 通过浏览器的开发者模式，我们可以看到webpack-dev-server创建了websocket server. 有戏了！我们可以在app端创建webscoket与webpack-dev-server连接。下面我们对webpack-dev-server源码进行分析 打开node_modules文件夹下的webpack-dev-server.我们主要看client/index.js和lib/Server.js文件： client/index.js获取webscoket地址和端口，赋值为urlParts： 1234567891011121314151617181920var urlParts = void 0;var hotReload = true;if (typeof window !== 'undefined') { var qs = window.location.search.toLowerCase(); hotReload = qs.indexOf('hotreload=false') === -1;}if (typeof __resourceQuery === 'string' &amp;&amp; __resourceQuery) { // If this bundle is inlined, use the resource query to get the correct url. urlParts = url.parse(__resourceQuery.substr(1));} else { // Else, get the url from the &lt;script&gt; this file was called with. var scriptHost = getCurrentScriptSource(); // eslint-disable-next-line no-useless-escape scriptHost = scriptHost.replace(/\\/[^\\/]+$/, ''); urlParts = url.parse(scriptHost || '/', false, true);}if (!urlParts.port || urlParts.port === '0') { urlParts.port = self.location.port;} 初始化对scoket消息的处理： 123456789101112131415161718var onSocketMsg = { hot: function hot() { _hot = true; log.info('[WDS] Hot Module Replacement enabled.'); }, invalid: function invalid() { log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain. if (useWarningOverlay || useErrorOverlay) overlay.clear(); sendMsg('Invalid'); }, ... 'content-changed': function contentChanged() { log.info('[WDS] Content base changed. Reloading...'); self.location.reload(); }, ...}; 链接websocket服务器： 123456789var socketUrl = url.format({ protocol: protocol, auth: urlParts.auth, hostname: hostname, port: urlParts.port, pathname: urlParts.path == null || urlParts.path === '/' ? '/sockjs-node' : urlParts.path});socket(socketUrl, onSocketMsg); 上文中，我们可以看到，webscoket客户端接收到content-changed消息后self.location.reload();对页面进行刷新。 我们再看看websocket服务器端是否发送了content-changed消息。 lib/Server.js发送content-changed消息： 123456789101112131415161718192021222324Server.prototype._watch = function (watchPath) { // duplicate the same massaging of options that watchpack performs // https://github.com/webpack/watchpack/blob/master/lib/DirectoryWatcher.js#L49 // this isn't an elegant solution, but we'll improve it in the future const usePolling = this.watchOptions.poll ? true : undefined; // eslint-disable-line no-undefined const interval = typeof this.watchOptions.poll === 'number' ? this.watchOptions.poll : undefined; // eslint-disable-line no-undefined const options = { ignoreInitial: true, persistent: true, followSymlinks: false, depth: 0, atomic: false, alwaysStat: true, ignorePermissionErrors: true, ignored: this.watchOptions.ignored, usePolling, interval }; const watcher = chokidar.watch(watchPath, options).on('change', () =&gt; { this.sockWrite(this.sockets, 'content-changed'); }); this.contentBaseWatchers.push(watcher);}; 现在弄清楚了webpack-dev-server的hotreload。诶…我们似乎跑远了。 app客户端需要监听websocket server，当收到content-changed消息时，对页面进行刷新。 Android客户端链接webpack-dev-server的socket服务器直接链接host:8081端口无法成功。在分析lib/Server.js代码，发现了这样一句代码： 12345...sockServer.installHandlers(this.listeningApp, { prefix: '/sockjs-node'});... 再看webpacke-dev-server使用的socket库sockjs-node，发现了这样一段话： 于是，将Android客户端的socket链接地址改为ws://host:8081/sockjs-node/websocket。成功了！！！socket链接打通。Android端部分代码： 123456789101112private void startHotRefresh() { try{ URL host = new URL(mUri.toString()); String wsUrl = \"ws://\" + host.getHost() + \":\" + host.getPort() + \"/sockjs-node/websocket\"; if (host.getPort() &lt; 0) { wsUrl = \"ws://\" + host.getHost() + \"/sockjs-node/websocket\"; } ... } catch (MalformedURLException e) { e.printStackTrace(); } } 走到这里，只剩下对消息的处理。修改js代码，在playground的HotRefreshManager.java中打印接收到的消息，发现没有content-changed,接收到的都是{&quot;type&quot;:&quot;progress-update&quot;,&quot;data&quot;:{&quot;percent&quot;:95,&quot;msg&quot;:&quot;emitting&quot;}}。万幸的是消息最后跟了一个{&quot;type&quot;:&quot;ok&quot;}。所以，暂且将{&quot;type&quot;:&quot;ok&quot;}作为触发刷新的点。 在HotRefreshManager.WXWebSocketListener: 12345678@Overridepublic void onMessage(WebSocket webSocket, String text) { Log.i(\"Receiving : \", text); if (text.equals(\"{\\\"type\\\":\\\"ok\\\"}\")) { Log.i(\"onMessage\", \"done\"); mHandler.obtainMessage(Constants.HOT_REFRESH_REFRESH).sendToTarget(); }} 最后，成功实现Android端自动刷新页面的效果。 文中还有不完善的地方，待后续补充。","link":"/2018/02/27/weex-hotreload/"}],"tags":[{"name":"chart","slug":"chart","link":"/tags/chart/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"J2V8","slug":"J2V8","link":"/tags/J2V8/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"富文本编辑器","slug":"富文本编辑器","link":"/tags/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8/"},{"name":"组件库","slug":"组件库","link":"/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"},{"name":"vant","slug":"vant","link":"/tags/vant/"},{"name":"TLS1.3","slug":"TLS1-3","link":"/tags/TLS1-3/"},{"name":"Facebook","slug":"Facebook","link":"/tags/Facebook/"},{"name":"echarts","slug":"echarts","link":"/tags/echarts/"},{"name":"candlestick","slug":"candlestick","link":"/tags/candlestick/"},{"name":"Parcel","slug":"Parcel","link":"/tags/Parcel/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"h5","slug":"h5","link":"/tags/h5/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"debug","slug":"debug","link":"/tags/debug/"},{"name":"chromium","slug":"chromium","link":"/tags/chromium/"},{"name":"vue-cli-2.9","slug":"vue-cli-2-9","link":"/tags/vue-cli-2-9/"},{"name":"rollup","slug":"rollup","link":"/tags/rollup/"},{"name":"vue-cli","slug":"vue-cli","link":"/tags/vue-cli/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"vue-style-loader","slug":"vue-style-loader","link":"/tags/vue-style-loader/"}],"categories":[{"name":"web","slug":"web","link":"/categories/web/"}]}